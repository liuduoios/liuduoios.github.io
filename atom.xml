<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Knowledge Library</title>
  
  <subtitle>个人博客</subtitle>
  <link href="https://liuduoios.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuduoios.github.io/"/>
  <updated>2023-06-08T04:09:25.132Z</updated>
  <id>https://liuduoios.github.io/</id>
  
  <author>
    <name>晨曦微光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在群辉上解决 Docker Hub 加载不出来的问题</title>
    <link href="https://liuduoios.github.io/solve-docker-hub-load-problem-on-synology/"/>
    <id>https://liuduoios.github.io/solve-docker-hub-load-problem-on-synology/</id>
    <published>2023-06-05T06:52:30.000Z</published>
    <updated>2023-06-08T04:09:25.132Z</updated>
    
    <content type="html"><![CDATA[<p>群辉上有个 Docker 套件，内置了 Docker Hub，可以方便地从 Docker Hub 下载镜像。但是在国内，因为不可说的原因，这个 Docker Hub 加载不出来，如下图所示，于是开始着手解决这个问题。</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605145836324-c.png"></p><h2 id="第一步：尝试使用-Docker-Hub-镜像"><a href="#第一步：尝试使用-Docker-Hub-镜像" class="headerlink" title="第一步：尝试使用 Docker Hub 镜像"></a>第一步：尝试使用 Docker Hub 镜像</h2><p>在网上搜索了 Docker Hub 镜像，主要有下面这些：</p><ul><li>DaoCloud 镜像站：<a href="https://docker.m.daocloud.io/">https://docker.m.daocloud.io</a></li><li>Azure 中国镜像：<a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></li><li>阿里云：https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com （需登录）</li><li>网易云：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></li><li>百度云：<a href="https://mirror.baidubce.com/">https://mirror.baidubce.com</a></li></ul><p>我把这些镜像地址在群辉的 Docker 套件中每个都试了试。除了阿里云那个以外，因为阿里云那个需要登录。</p><p>在群辉 Docker 套件中配置镜像步骤如下：</p><p>点击注册表选项卡中的设置按钮</p><p><img src="/solve-docker-hub-load-problem-on-synology/%E6%88%AA%E5%B1%8F2023-06-05-15.05.35-c.png" alt="截屏2023-06-05 15.05.35"></p><p>选择 Docker Hub 这一行以后，点击”编辑“</p><p><img src="/solve-docker-hub-load-problem-on-synology/%E6%88%AA%E5%B1%8F2023-06-05-15.17.43-c.png" alt="截屏2023-06-05 15.05.35"></p><p>勾选上”启用注册表镜像“，然后把镜像 URL 填入”注册表镜像 URL：” 文本框中。</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605152021309-c.png"></p><p>点击确定后会弹出提示，要重新启动 Docker 容器，问是否继续，点击“是”。</p><p>然后显示“加载中…”，等待了一会，加载中提示消失，界面还是空白一片的。于是试着把 Docker 套件关闭再重新打开，甚至也试了将 Docker 套件停用再启动。然后点到注册表这个界面时，还是显示文章最开头的那张图——“查询注册表失败”。</p><p>上面的每个镜像地址配置进去都不行，最后登录了阿里云，在阿里云里找到“容器镜像服务”，在里面拿到了我的镜像地址，配置进去，还是一样的不行。</p><p>很奇怪，是这些镜像地址都失效了还是我配置的不对？</p><h2 id="第二步：尝试使用群辉的系统代理设置"><a href="#第二步：尝试使用群辉的系统代理设置" class="headerlink" title="第二步：尝试使用群辉的系统代理设置"></a>第二步：尝试使用群辉的系统代理设置</h2><p>因为我本机 mac 电脑上安装并运行着 Clash，我就尝试设置群辉的系统代理到我的电脑上，设置如下图，然后点击“应用”保存设置。</p><p><img src="/solve-docker-hub-load-problem-on-synology/%E6%88%AA%E5%B1%8F2023-06-05-15.29.15-c.png"></p><p>但是还是不行，于是我 ssh 登录到群辉上，输入 <code>curl www.google.com</code>，依然打不开，提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to 192.168.0.109 port 7890 after 11 ms: Connection refused</span><br></pre></td></tr></table></figure><p>连接被拒绝了。然后我检查了一下 Clash 的菜单，发现有一个”允许局域网连接“，并勾选上它。</p><p><img src="/solve-docker-hub-load-problem-on-synology/%E6%88%AA%E5%B1%8F2023-06-05-15.33.43-c.png"></p><p>这时再次 <code>curl www.google.com</code> 就有结果了，能正常访问了。</p><p>然后把 Docker 套件关闭重新打开，点击注册表。</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605153616859-c.png"></p><p>Very Good！</p><p>但是这样代理到我的 mac 上不是长久之计，于是进入第三步。</p><h2 id="第三步：在群辉上运行-Clash"><a href="#第三步：在群辉上运行-Clash" class="headerlink" title="第三步：在群辉上运行 Clash"></a>第三步：在群辉上运行 Clash</h2><p>在注册表中搜索 clash</p><p><img src="/solve-docker-hub-load-problem-on-synology/%E6%88%AA%E5%B1%8F2023-06-05-15.40.42-c.png"></p><p>下载第一个名为 dramacro&#x2F;clash 的映像。</p><p>下载好以后，通过左边侧边栏切换到映像界面，找到刚下载好的这个映像并启动。</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605154417553-c.png"></p><p>点下一步直到端口设置界面，添加以下两个端口映射：</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605154718583-c.png"></p><p>这里如果你没有和我一样使用 mixed-port，可能要多配置一个端口。使用了 mixed-port 就都走 7890 这个默认端口就可以了。9090 端口是访问管理面板用的。</p><p>然后点下一步，启动这个容器。</p><p>不过看到有人说这个映像有偷跑流量的问题，有可能是因为群辉拥有公网 IP，并且这个容器使用了默认的 7890 端口被别人扫描到了，这种情况可以把端口号修改为其它端口号。也有人说是这个映像自带后门，这个就不清楚了，等我尝试一阵子看看。</p><p>然后再下载 haishanh&#x2F;yacd 这个映像，这是 Clash 的管理面板，用来对 Clash 做一些配置，例如选择模式和线路。</p><p>我也尝试了一些在线的，例如 <a href="http://yacd.haishan.me/">http://yacd.haishan.me/</a>，但是设置了 IP 和端口号后会连接失败，不知道什么原因。用上面的 haishanh&#x2F;yacd 没有这个问题。</p><h2 id="第四步：设置群辉系统代理"><a href="#第四步：设置群辉系统代理" class="headerlink" title="第四步：设置群辉系统代理"></a>第四步：设置群辉系统代理</h2><p>现在 Clash 容器已经运行起来了，回到群辉系统控制面板 -&gt; 网络设置，设置代理服务器：</p><p><img src="/solve-docker-hub-load-problem-on-synology/image-20230605213550066-c.png"></p><p>现在再打开 Docker 套件的注册表，OK，一切正常显示了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;群辉上有个 Docker 套件，内置了 Docker Hub，可以方便地从 Docker Hub 下载镜像。但是在国内，因为不可说的原因，这个 Docker Hub 加载不出来，如下图所示，于是开始着手解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/solve-dock</summary>
      
    
    
    
    <category term="网络" scheme="https://liuduoios.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Docker" scheme="https://liuduoios.github.io/tags/Docker/"/>
    
    <category term="群辉" scheme="https://liuduoios.github.io/tags/%E7%BE%A4%E8%BE%89/"/>
    
    <category term="Clash" scheme="https://liuduoios.github.io/tags/Clash/"/>
    
    <category term="代理" scheme="https://liuduoios.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>详解 Codable 的用法和原理</title>
    <link href="https://liuduoios.github.io/codable-usage-and-theory/"/>
    <id>https://liuduoios.github.io/codable-usage-and-theory/</id>
    <published>2022-09-13T01:01:19.000Z</published>
    <updated>2023-06-05T05:33:26.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codable-是什么"><a href="#Codable-是什么" class="headerlink" title="Codable 是什么"></a>Codable 是什么</h1><p>Codable 本身就是个类型别名</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Codable</span> <span class="operator">=</span> <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br></pre></td></tr></table></figure><p>代表一个同时符合 Decodable 和 Encodable 协议的类型，即可解码且可编码的类型。</p><p>Codable 也可以代表苹果为 Swift 开发的一套编解码系统，从 Swift 4 开始引入，包含了 Encoder 和 Decoder 协议和他们的两个实现 <code>JSONEncoder</code>、<code>JSONDecoder</code> 和 <code>PropertyListEncoder</code>、<code>PropertyListDecoder</code>。其中 Codable 及其相关协议放在了标准库中，而具体的 Encoder、Decoder 类放在了 <code>Foundation</code> 框架中。</p><h1 id="Codable-的用法"><a href="#Codable-的用法" class="headerlink" title="Codable 的用法"></a>Codable 的用法</h1><p>Codable 是用来做系统自身数据结构和外部公共数据结构做转换的。系统内部数据结构可以是基础类型、结构体、枚举、类等，外部公共数据结构可以是 JSON、XML 等。</p><h2 id="JSON-和-模型的相互转换"><a href="#JSON-和-模型的相互转换" class="headerlink" title="JSON 和 模型的相互转换"></a>JSON 和 模型的相互转换</h2><p>用 Objective-C 做 JSON 和模型转换时，一般要使用一些第三方库，这些第三方库基本上都是利用了 Objective-C Runtime 的强大特性来实现 JSON 和模型互转的。</p><p>但是 Swift 是一门静态语言，本身是没有像 Objective-C 那样的动态 Runtime 的。虽然在 Swift 中也可以通过继承 NSObject 的方式，来使用基于 OC Runtime 的 JSON 模型互转方案。但是这样就很不 Swift，也放弃了 Swift 作为一门静态语言的高性能，等于说自己降低了整个项目的运行性能，这是无法忍受的。</p><p>好在苹果提供了 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 这两个结构体来方便得在 JSON 数据和自定义模型之间互相转换。苹果可以利用一些系统私有的机制来实现转换，而不需要通过 <code>OC Runtime</code>。</p><p>只要让自己的数据类型符合 Codable 协议，就可以用系统提供的编解码器进行编解码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体编解码代码如下：</p><h4 id="解码（JSON-Data-gt-Model）："><a href="#解码（JSON-Data-gt-Model）：" class="headerlink" title="解码（JSON Data -&gt; Model）："></a>解码（JSON Data -&gt; Model）：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;zhangsan&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 25</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.data(using: .utf8)<span class="operator">!</span></span><br><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> <span class="type">JSONDecoder</span>().decode(<span class="type">User</span>.<span class="keyword">self</span>, from: json)</span><br></pre></td></tr></table></figure><h4 id="编码（Model-gt-JSON-Data）："><a href="#编码（Model-gt-JSON-Data）：" class="headerlink" title="编码（Model -&gt; JSON Data）："></a>编码（Model -&gt; JSON Data）：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="type">JSONEncoder</span>().encode(user)</span><br></pre></td></tr></table></figure><h2 id="Codable-支持的数据类型"><a href="#Codable-支持的数据类型" class="headerlink" title="Codable 支持的数据类型"></a>Codable 支持的数据类型</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>在 Swift 标准库的声明文件中可以看到，基础类型都通过 <code>extension</code> 实现了 <code>Codable</code> 协议。</p><p>对于基础类型的属性，JSONEncoder 和 JSONDecoder 都可以正确的处理。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><code>JSONEncoder</code> 提供了 <code>dateEncodingStrategy</code> 属性来指定日期编码策略。<br>同样 <code>JSONDecoder</code> 提供了 <code>dateDecodingStrategy</code> 属性。</p><p>就拿 <code>dateDecodingStrategy</code> 为例，它是一个枚举类型。枚举类型有以下几个 case:</p><table><thead><tr><th>case 名</th><th>作用</th></tr></thead><tbody><tr><td><code>case deferredToDate</code></td><td>默认的 case</td></tr><tr><td><code>case iso8601</code></td><td>按照日期的 ios8601 标准来解码日期</td></tr><tr><td><code>case formatted(DateFormatter)</code></td><td>自定义日期解码策略，需要提供一个 DateFormatter 对象</td></tr><tr><td><code>case custom((_ decoder: Decoder) throws -&gt; Date)</code></td><td>自定义日期解码策略，需要提供一个 Decoder -&gt; Date 的闭包</td></tr></tbody></table><p>通常使用比较多的就是 <code>.iso8601</code> 了，因为后端返回日期通常都是已 ios8601 格式返回的。只要 JSON 中的日期是 ios8601 规范的字符串，只要设置一行代码就能让 JSONDecoder 完成日期的解码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> birthday: <span class="type">Date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;zhangsan&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot;: 25,</span></span><br><span class="line"><span class="string">        &quot;birthday&quot;: &quot;2022-09-12T10:25:41+00:00&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.data(using: .utf8)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder <span class="operator">=</span> <span class="type">JSONDecoder</span>()</span><br><span class="line">decoder.dateDecodingStrategy <span class="operator">=</span> .iso8601</span><br><span class="line"><span class="keyword">let</span> user <span class="operator">=</span> decoder.decode(<span class="type">User</span>.<span class="keyword">self</span>, from: json)</span><br><span class="line"><span class="comment">// user.birthday 正确解码为 Date 类型</span></span><br></pre></td></tr></table></figure><h3 id="嵌套对象"><a href="#嵌套对象" class="headerlink" title="嵌套对象"></a>嵌套对象</h3><p>在自定义模型中嵌套对象的时候，只要这个嵌套对象也符合 Codable 协议，那整个对象就可以正常使用 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 编解码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UserInfo</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> info: <span class="type">UserInfo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型必须它的 RawValue 的类型是可解码的，并且 RawValue 的类型和 JSON 字段类型对应，即可正确解码。</p><h2 id="自定义-CodingKeys"><a href="#自定义-CodingKeys" class="headerlink" title="自定义 CodingKeys"></a>自定义 CodingKeys</h2><p>自定义 CodingKeys 主要是两个目的</p><ol><li>当数据类型属性名和 JSON 中字段名不同时，做 key 的映射。</li><li>通过在不添加某些字段的 case，来跳过某些字段的编解码过程。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> birthday: <span class="type">Date</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name <span class="operator">=</span> <span class="string">&quot;userName&quot;</span></span><br><span class="line">        <span class="keyword">case</span> age <span class="operator">=</span> <span class="string">&quot;userAge&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CodingKeys 必须是一个 RawValue 为 String 类型的枚举，并符合 <code>CodingKey</code> 协议。以上代码实现的效果为，为 name 和 age 字段做了 key 映射，让编解码过程中不包含 birthday 字段。</p><h1 id="Codable-的原理"><a href="#Codable-的原理" class="headerlink" title="Codable 的原理"></a>Codable 的原理</h1><p>了解了 Codable 的用法，下面我们来看一看 Codable 的原理。</p><h2 id="Decodable-协议"><a href="#Decodable-协议" class="headerlink" title="Decodable 协议"></a>Decodable 协议</h2><p>由于编码和解码的原理差不多只是方向不同，我们仅探索用的更多的解码过程。</p><p>如果想让一个对象支持解码应该怎么做呢，当然是符合 Decodable 协议。我们先看看一个对象符合 Decodable 协议需要做哪些事情。</p><p><code>Decodable</code> 协议的定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说只要实现一个传入 Decoder 参数的初始化方法，于是我们自己来实现 User。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在要来看看怎样让 User 的两个属性的值能从 Decoder 这个对象得到。</p><p>查看 <code>Decoder</code> 的定义，它是一个协议。<br>有两个属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span> : <span class="keyword">Any</span>] &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>还有三个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">container</span>&lt;<span class="type">Key</span>&gt;(<span class="params">keyedBy</span> <span class="params">type</span>: <span class="type">Key</span>.<span class="keyword">Type</span>) <span class="keyword">throws</span> -&gt; <span class="type">KeyedDecodingContainer</span>&lt;<span class="type">Key</span>&gt; <span class="keyword">where</span> <span class="type">Key</span> : <span class="type">CodingKey</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">unkeyedContainer</span>() <span class="keyword">throws</span> -&gt; <span class="type">UnkeyedDecodingContainer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">singleValueContainer</span>() <span class="keyword">throws</span> -&gt; <span class="type">SingleValueDecodingContainer</span></span><br></pre></td></tr></table></figure><p>会发现这三个方法返回的都是 XXXContainer，从字面上理解是个容器，容器里面一定是容纳了某些东西。</p><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>再查看这些 Container 的定义，会发现里面都有一系列 decode… 方法，来对各种类型进行 decode。</p><p>一共有三种类型的 Container：</p><table><thead><tr><th>Container 类型</th><th>作用</th></tr></thead><tbody><tr><td>SingleValueDecodingContainer</td><td>代表容器中只保存了一个值</td></tr><tr><td>KeyedDecodingContainer</td><td>代表容器中保存的数据是按照键值对的形式保存的</td></tr><tr><td>UnkeyedDecodingContainer</td><td>代表容器中保存的数据是没有键的，也就是说，保存的数据是一个数组</td></tr></tbody></table><p>回到上面 User 的例子，JSON 数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这种数据显然是键值对，因此要用 KeyedDecodingContainer 来取数据。KeyedDecodingContainer 应该是最常用的 Container 了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        decoder.container(keyedBy: <span class="operator">&lt;</span>#<span class="type">T</span>##<span class="type">CodingKey</span>.<span class="keyword">Protocol</span>#<span class="operator">&gt;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数需要传一个符合 CodingKey 协议的对象的类型，于是这里必须自己实现 CodingKeys 枚举，并把 CodingKeys.self 传入参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct User: Decodable &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">    </span><br><span class="line">    enum CodingKeys: String, CodingKey &#123;</span><br><span class="line">        case name</span><br><span class="line">        case age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(from decoder: Decoder) throws &#123;</span><br><span class="line">        let container = decoder.container(keyedBy: CodingKeys.self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以从 container 中取数据出来赋给自身的属性。由于这几个方法都会抛出异常，因此都要加上 <code>try</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">    name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">    age <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们也可以实现出编码。这时把 User 实现的协议改成 <code>Codable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">        age <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> encoder <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> encoder.encode(name, forKey: .name)</span><br><span class="line">        <span class="keyword">try</span> encoder.encode(age, forKey: .age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码的过程就是和解码反过来，因为是键值对，从 encoder 中拿到 <code>KeyedEncoderContainer</code>，然后调用 encode 方法把属性的数据编码到 container 中，然后由 <code>JSONEncoder</code> 来处理接下来的事情。</p><p>接下来我们好奇的是，Container 中的数据是怎么保存的，Container 中的数据和 JSON 又是怎么互相转换的。</p><h2 id="核心原理分析（Container-lt-–-gt-JSON）"><a href="#核心原理分析（Container-lt-–-gt-JSON）" class="headerlink" title="核心原理分析（Container &lt;–&gt; JSON）"></a>核心原理分析（Container &lt;–&gt; JSON）</h2><h3 id="JSONDecoder-的解码过程"><a href="#JSONDecoder-的解码过程" class="headerlink" title="JSONDecoder 的解码过程"></a>JSONDecoder 的解码过程</h3><p>从 <code>JSONDecoder().decode(User.self, from: json)</code> 这句开始分析。打开 swift-corelibs-foundation 中 <code>JSONDecoder</code> 的源码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> parser <span class="operator">=</span> <span class="type">JSONParser</span>(bytes: <span class="type">Array</span>(data))</span><br><span class="line"><span class="keyword">let</span> json <span class="operator">=</span> <span class="keyword">try</span> parser.parse()</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSONDecoderImpl</span>(userInfo: <span class="keyword">self</span>.userInfo, from: json, codingPath: [], options: <span class="keyword">self</span>.options)</span><br><span class="line">    .unwrap(as: <span class="type">T</span>.<span class="keyword">self</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>decode 方法的实现主要是这三行代码。</p><ol><li>先把 data 转化为一个类型为 <code>JSONValue</code> 的 json 对象。</li><li>然后构造一个 JSONDecoderImpl 对象</li><li>调用 JSONDecoderImpl 对象的 <code>unwrap</code> 方法得到要转换成的对象。</li></ol><p>查看 <code>JSONValue</code> 的定义，它通过枚举嵌套把 JSON 的类型定义了出来。具体的数据通过关联值携带在了这个枚举类型中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">JSONValue</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> bool(<span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">case</span> null</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> array([<span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> object([String: <span class="type">JSONValue</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取 KeyedDecodingContainer 的时候也就是通过 JSONValue 构建 Container 对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里 self.json 是保存在 JSONDecoderImpl 中的 JSONValue 类型</span></span><br><span class="line"><span class="keyword">switch</span> <span class="keyword">self</span>.json &#123;</span><br><span class="line"><span class="keyword">case</span> .object(<span class="keyword">let</span> dictionary): <span class="comment">// JSONValue 和 .object 这个 case 匹配，取出字典数据</span></span><br><span class="line">    <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">KeyedContainer</span>&lt;<span class="type">Key</span>&gt;(</span><br><span class="line">        impl: <span class="keyword">self</span>,</span><br><span class="line">        codingPath: codingPath,</span><br><span class="line">        dictionary: dictionary <span class="comment">// 传入字典数据</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="type">KeyedDecodingContainer</span>(container)</span><br></pre></td></tr></table></figure><p>可以看到，<code>KeyedDecodingContainer</code> 只有当 <code>self.json</code> 匹配为字典时才能正确创建。数据在里面以 <code>let dictionary: [String: JSONValue]</code> 形式保存。</p><p>再看其他代码可以发现：</p><p><code>SingleValueContainer</code> 就是直接存了一个 <code>let value: JSONValue</code> 在里面。</p><p><code>UnkeyedDecodingContainer</code> 则是存了一个数组 <code>let array: [JSONValue]</code>。</p><p>因此在 Container 调用 <code>decode</code> 方法获取数据时，就是根据参数 key 和类型从自身保存的数据中获取数据。这个源码很简单，看一下就明白了。</p><p>最后一步的 unwrap 方法，通过源码可以看到，最终调用的就是对象自己实现的 <code>init(from decoder: Decoder)</code> 方法</p><p>因此可以得出 <strong>JSON -&gt; Model 的步骤</strong>如下：</p><ol><li>JSONParser 对传入的二进制 JSON data 进行解析，解析为 JSONValue 对象。</li><li>构建 JSONDecoderImpl，将相关的数据保存在里面。</li><li>调用 JSONDecoderImpl 的 unwrap 方法，开始调用对象实现的 <code>init(from: decoder: Decoder)</code> 方法</li><li>在 &#96;&#96;init(from: decoder: Decoder)&#96; 方法中，首先根据数据类型获取对应的 Container。</li><li>调用 Container 的 decodeXXX 方法得到具体的值赋值给属性。</li></ol><p>Model -&gt; JSON 的步骤也是差不多的，只是方向反过来，有兴趣可以自己看一下源码。</p><p>在 Swift 的 JSON 转模型方法中，通过观察 Github 上的开源库可以发现一共有三种实现方案：</p><ul><li><strong>Objective-C Runtime</strong> 一众本身就是 OC 开发的库基本都用的这个方案，比如 YYModel，这种方案使用起来非常简单，代码非常少，但不符合 Swift。</li><li><strong>Key 映射</strong> 比如 ObjectMapper 就是这种，这种的缺点是每个对象都要写一大堆映射代码，比较麻烦</li><li><strong>利用对象底层内存布局</strong> SwiftyJSON 就属于这种，这种方法使用起来一样很方便，但是依赖苹果的私有代码，苹果如果调整了内部实现就会失效。</li></ul><p>通过上面分析 Codable 原理发现，Codable 基本上就是 Key 映射的方案，只不过编译器帮我们自动合成了很多代码来让我们使用起来一样可以非常简单。由于编译器不会帮第三方库合成代码，因此 Codable 秒杀了一众基于 key 映射实现的第三方库。</p><h2 id="编译器帮我们做了什么？"><a href="#编译器帮我们做了什么？" class="headerlink" title="编译器帮我们做了什么？"></a>编译器帮我们做了什么？</h2><p>我们发现，只要让自己的对象符合 Codable 协议，就可以正常用 <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 编解码，并不需要实现协议中定义的方法。</p><p>那是因为编译器帮我们生成了。这种编译器合成代码在很多地方都会用到，例如为结构体和枚举自动合成实现 Equatable 和 Hashable 的代码，为枚举合成实现 CaseIterable 的代码等。</p><p>上面的 User 例子，编译器为我们合成的代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译器合成</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译器合成</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        name <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name)</span><br><span class="line">        age <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译器合成</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> encoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">try</span> container.encode(name, forKey: .name)</span><br><span class="line">        <span class="keyword">try</span> container.encode(age, forKey: .age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以见到，编译器自动合成了 CodingKeys 枚举的定义，并合成了实现 Encodable 和 Decodable 协议的代码。这给开发人员提供了方便。</p><h1 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h1><p>编译器自动生成的编解码实现有个问题就是不支持默认值。如果需要支持默认值就需要自己来用 <code>decodeIfPresent</code> 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>: <span class="title class_">Decodable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CodingKeys</span>: <span class="title class_">String</span>, <span class="title class_">CodingKey</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> name</span><br><span class="line">        <span class="keyword">case</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.container(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)</span><br><span class="line">        name <span class="operator">=</span> <span class="keyword">try</span> container.decodeIfPresent(<span class="type">String</span>.<span class="keyword">self</span>, forKey: .name) <span class="operator">??</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        age <span class="operator">=</span> <span class="keyword">try</span> container.decodeIfPresent(<span class="type">Int</span>.<span class="keyword">self</span>, forKey: .age) <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样每个结构体都要自己实现一次，非常麻烦。其实这个网上已经有很多文章在说了，就是用 <code>@propertyWrapper</code> 属性包装器来解决这个问题。</p><h2 id="属性包装器-propertyWrapper"><a href="#属性包装器-propertyWrapper" class="headerlink" title="属性包装器 @propertyWrapper"></a>属性包装器 @propertyWrapper</h2><p>属性包装器用来给属性和定义属性的结构之间包装一层，用来实现一些通用的 setter 和 getter 逻辑或初始化逻辑等。</p><p>例如对于 Int 型，可以如下定义属性包装器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">DefaultInt</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.singleValueContainer()</span><br><span class="line">        wrappedValue <span class="operator">=</span> (<span class="keyword">try?</span> container.decode(<span class="type">BaseType</span>.<span class="keyword">self</span>)) <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> wrappedValue.encode(to: encoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了 <code>init(from decoder: Decoder)</code> 方法来为属性在解码失败时提供一个默认值 0。实现 <code>encode(to encoder: Encoder)</code> 是为了编码时直接编码内部值而不是编码整个属性包装类型。</p><p>其它的很多基础类型都是一样的逻辑，为了避免重复代码，可以用范型来统一实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">HasDefaultValue</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: <span class="keyword">Self</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">DefaultBaseType</span>&lt;<span class="title class_">BaseType</span>: <span class="title class_">Codable</span> &amp; <span class="title class_">HasDefaultValue</span>&gt;: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">BaseType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.singleValueContainer()</span><br><span class="line">        wrappedValue <span class="operator">=</span> (<span class="keyword">try?</span> container.decode(<span class="type">BaseType</span>.<span class="keyword">self</span>)) <span class="operator">??</span> <span class="type">BaseType</span>.defaultValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> wrappedValue.encode(to: encoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以考虑用类型别名来定义出各个类型的属性包装关键字。因为如果包含 <code>&lt;</code> 或 <code>.</code> 等字符，写起来会比较麻烦。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">DefaultInt</span> <span class="operator">=</span> <span class="type">DefaultBaseType</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">DefaultString</span> <span class="operator">=</span> <span class="type">DefaultBaseType</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure><p>但是有些类型需要特殊实现一下。</p><h3 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型可以利用 rawValue 来进行数据和类型相互转换。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">DefaultIntEnum</span>&lt;<span class="title class_">Value</span>: <span class="title class_">RawRepresentable</span> &amp; <span class="title class_">HasDefaultEnumValue</span>&gt;: <span class="title class_">Codable</span> <span class="title class_">where</span> <span class="title class_">Value</span>.<span class="title class_">RawValue</span> == <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> intValue <span class="operator">=</span> <span class="type">Value</span>.defaultValue.rawValue</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="type">Value</span>(rawValue: intValue)<span class="operator">!</span> &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; intValue <span class="operator">=</span> newValue.rawValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.singleValueContainer()</span><br><span class="line">        intValue <span class="operator">=</span> (<span class="keyword">try?</span> container.decode(<span class="type">Int</span>.<span class="keyword">self</span>)) <span class="operator">??</span> <span class="type">Value</span>.defaultValue.rawValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> intValue.encode(to: encoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>由于数组需要通过 UnkeyedDecodingContainer 拿数据，需要单独特殊处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">DefaultArray</span>&lt;<span class="title class_">Value</span>: <span class="title class_">Codable</span>&gt;: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: [<span class="type">Value</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        wrappedValue <span class="operator">=</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">wrappedValue</span>: [<span class="type">Value</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.wrappedValue <span class="operator">=</span> wrappedValue</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">from</span> <span class="params">decoder</span>: <span class="type">Decoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> container <span class="operator">=</span> <span class="keyword">try</span> decoder.unkeyedContainer()</span><br><span class="line">        <span class="keyword">var</span> results <span class="operator">=</span> [<span class="type">Value</span>]()</span><br><span class="line">        <span class="keyword">while</span> <span class="operator">!</span>container.isAtEnd &#123;</span><br><span class="line">            <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">try</span> container.decode(<span class="type">Value</span>.<span class="keyword">self</span>)</span><br><span class="line">            results.append(value)</span><br><span class="line">        &#125;</span><br><span class="line">        wrappedValue <span class="operator">=</span> results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">encode</span>(<span class="params">to</span> <span class="params">encoder</span>: <span class="type">Encoder</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> wrappedValue.encode(to: encoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>因为对象的结构都是不一样的，没法给出一个的默认值。因此设计了一个 <code>EmptyInitializable</code> 协议，里面只有一个无参数的初始化方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">EmptyInitializable</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要提供默认值的对象可以实现这个协议。不过这里需要权衡一下，如果对内存空间占用有比较高的要求，用可选值可能是更好的方案，因为一个空对象占用的空间和有数据的对象占用的空间是一样多的。</p><h3 id="属性包装器的使用"><a href="#属性包装器的使用" class="headerlink" title="属性包装器的使用"></a>属性包装器的使用</h3><p>使用属性包装器封装各个类型后，只要像这样使用就可以了，decode 的时候就如果不存在对应字段数据属性就会初始化为默认值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@DefaultString</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="meta">@DefaultInt</span> <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我简单封装了一个库，目前我们的新 Swift 项目在使用，完整代码在这里： <a href="https://github.com/liuduoios/CodableDefaultValue">https://github.com/liuduoios/CodableDefaultValue</a></p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><ul><li>《the swift programming language》</li><li>《Advanced Swift》</li><li>swift-corelibs-foundation 源码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Codable-是什么&quot;&gt;&lt;a href=&quot;#Codable-是什么&quot; class=&quot;headerlink&quot; title=&quot;Codable 是什么&quot;&gt;&lt;/a&gt;Codable 是什么&lt;/h1&gt;&lt;p&gt;Codable 本身就是个类型别名&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>探索 Objective-C 的对象所有权修饰符</title>
    <link href="https://liuduoios.github.io/objectivec-ownership/"/>
    <id>https://liuduoios.github.io/objectivec-ownership/</id>
    <published>2022-09-08T10:36:00.000Z</published>
    <updated>2023-06-05T05:33:26.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>大家都知道，Objective-C 有 4 个对象所有权修饰符（Ownership Qualifier），分别是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span></span><br><span class="line">__<span class="keyword">weak</span></span><br><span class="line">__<span class="keyword">unsafe_unretained</span></span><br><span class="line">__autoreleasing</span><br></pre></td></tr></table></figure><p>在日常开发中日常用的最多的就是 <code>__weak</code>，几乎都是为了解决循环引用的问题。<code>__strong</code> 是一个变量默认的修饰符，不需要写。<code>__unsafe_unretained</code> 因为它的不安全，基本上不会去使用它。<code>__autoreleasing</code> 见得最多的地方估计就是 <code>NSError * __autoreleasing *</code> 这个类型声明了，似乎也没有地方需要自己写。</p><p>看到 <code>NSError * __autoreleasing *</code> 这个类型，不禁会思考，这个 <code>__autoreleasing</code> 为啥放在两个星号中间呢，如果放在两个星号的左边，或者放在两个星号的右边行不行呢？</p><p>于是又开始思考另一个相关的问题。我们知道声明常量的时候，const 的位置不同，实际含义就会不同。比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> <span class="keyword">const</span> *object;</span><br></pre></td></tr></table></figure><p>这里 object 是一个指针，指向一个 NSObject 类型的常量（通常把这种指针叫做指向常量的指针，或者常量指针）<br>这样声明的结果是 object 本身可以修改，但是 object 指向的内容不能修改。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * <span class="keyword">const</span> object;</span><br></pre></td></tr></table></figure><p>这里的 object 是一个常量，它的类型是一个指针（通常把这种类型叫做指针常量）<br>这样声明的结果是 object 本身不可以修改，但是 object 指向的内容可以修改。<br>但是因为 Objective-C 不支持对对象指针的解引用进行赋值，因此 object 指向的内容也无法修改。即 <code>*str1 = *str2;</code> 这类操作是不允许的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">NSString</span> *str = <span class="string">@&quot;this is a string&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中的 const 其实是毫无意义的。</p><p>还有 object 本身和 object 指向的内容都不能修改的情况，即：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> <span class="keyword">const</span> * <span class="keyword">const</span> object;</span><br></pre></td></tr></table></figure><p>那么作为类比，对于 __strong 修饰符来说：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * __<span class="keyword">strong</span> o;</span><br><span class="line"><span class="built_in">NSObject</span> __<span class="keyword">strong</span> * o;</span><br></pre></td></tr></table></figure><p>上面两句代码有什么区别？第二行中的 * 和 o 之间，日常开发时是不写空格的，这里只是为了对齐。</p><h1 id="NSObject-strong-o-和-NSObject-strong-o-的区别"><a href="#NSObject-strong-o-和-NSObject-strong-o-的区别" class="headerlink" title="NSObject * __strong o; 和 NSObject __strong *o; 的区别"></a><code>NSObject * __strong o;</code> 和 <code>NSObject __strong *o;</code> 的区别</h1><h3 id="探索步骤1，转成-C-代码"><a href="#探索步骤1，转成-C-代码" class="headerlink" title="探索步骤1，转成 C++ 代码"></a>探索步骤1，转成 C++ 代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> * __<span class="keyword">strong</span> o1;</span><br><span class="line">    <span class="built_in">NSObject</span> __<span class="keyword">strong</span> *o2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面这个 main 函数转成 C++ 代码后的结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    NSObject __attribute__((<span class="built_in">objc_ownership</span>(strong))) *o1;</span><br><span class="line">    NSObject * __attribute__((<span class="built_in">objc_ownership</span>(strong))) o2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去 <code>__strong</code> 被类似宏替换的操作替换成了 <code>__attribute__((objc_ownership(strong)))</code>，看不出什么东西。</p><h3 id="探索步骤2，查看汇编代码"><a href="#探索步骤2，查看汇编代码" class="headerlink" title="探索步骤2，查看汇编代码"></a>探索步骤2，查看汇编代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> * __<span class="keyword">strong</span> o1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> __<span class="keyword">strong</span> *o2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别查看上面两个 main 函数的汇编代码，会发现结果都是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">XXXXXX`main:</span><br><span class="line">    0x100003ec4 &lt;+0&gt;:  sub    sp, sp, #0x30</span><br><span class="line">    0x100003ec8 &lt;+4&gt;:  stp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100003ecc &lt;+8&gt;:  add    x29, sp, #0x20</span><br><span class="line">    0x100003ed0 &lt;+12&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x100003ed4 &lt;+16&gt;: stur   w0, [x29, #-0x8]</span><br><span class="line">    0x100003ed8 &lt;+20&gt;: str    x1, [sp, #0x10]</span><br><span class="line">    0x100003edc &lt;+24&gt;: add    x0, sp, #0x8</span><br><span class="line">    0x100003ee0 &lt;+28&gt;: mov    x1, #0x0</span><br><span class="line">    0x100003ee4 &lt;+32&gt;: str    xzr, [sp, #0x8]</span><br><span class="line">    0x100003ee8 &lt;+36&gt;: stur   wzr, [x29, #-0x4]</span><br><span class="line">    0x100003eec &lt;+40&gt;: bl     0x100003f3c               ; symbol stub for: objc_storeStrong</span><br><span class="line">    0x100003ef0 &lt;+44&gt;: ldur   w0, [x29, #-0x4]</span><br><span class="line">    0x100003ef4 &lt;+48&gt;: ldp    x29, x30, [sp, #0x20]</span><br><span class="line">    0x100003ef8 &lt;+52&gt;: add    sp, sp, #0x30</span><br><span class="line">    0x100003efc &lt;+56&gt;: ret    </span><br></pre></td></tr></table></figure><p>所以这两种顺序的写法的效果应该是一样的。</p><p>所以其实：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * __<span class="keyword">strong</span> o;</span><br><span class="line"><span class="built_in">NSObject</span> __<span class="keyword">strong</span> *o;</span><br><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSObject</span> *o</span><br></pre></td></tr></table></figure><p>上面这三种写法都是一样的。</p><p>对于另外三个修饰也都是一样，我们可以测试一下 <code>__autoreleasing</code> 修饰符。先随便创建一个类里面写上如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)cat &#123;</span><br><span class="line">    Cat *cat = [[Cat alloc] init];</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后编写 main 函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    Cat * __autoreleasing cat = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        cat = [Cat cat];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;outside of the autoreleasepool&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，无论 <code>__autoreleasing</code> 写在哪个位置，都可以让 cat 对象在打印 outside of the autoreleasepool 之前就被销毁。</p><p>所以对于一级指针，修饰符放在哪个位置都一样，那么对于二级指针呢？</p><p>在探讨二级指针之前，先了解一下 <code>NSError * __autoreleasing *</code> 是什么意思，以及为什么这里要写成这样。</p><h1 id="为什么-NSError-autoreleasing-要用二级指针？"><a href="#为什么-NSError-autoreleasing-要用二级指针？" class="headerlink" title="为什么 NSError * __autoreleasing * 要用二级指针？"></a>为什么 <code>NSError * __autoreleasing *</code> 要用二级指针？</h1><p>其实 <code>NSError * __autoreleasing *</code> 是 MRC（或者叫 MRR）时代的写法，在 ARC 时代，可以省去 <code>__autoreleasing</code> 修饰符，直接写成 <code>NSError **</code>，编译器会自动对某些变量设为 <code>__autoreleasing</code>。所以对于 ARC 的 <code>NSError **</code> 类型，编译器还是会把它处理成 <code>NSError * __autoreleasing *</code> 的语义。</p><p>在 ARC 下，用 Xcode 的代码自动补全功能时，自动补全的代码还是会对这个类型给出 <code>NSError *__autoreleasing  _Nullable * _Nullable</code> 的提示。</p><p>为了说明 <code>NSError * __autoreleasing *</code> 的含义，首先要先明白这里为什么要用二级指针。</p><p>举一个经常使用的 API，NSJSONSerialization 的例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="type">id</span>)JSONObjectWithData:(<span class="built_in">NSData</span> *)data options:(<span class="built_in">NSJSONReadingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure><p>这个方法的 error 参数用来在解析失败的时候提供具体错误信息，需要这么来使用它：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:&amp;error];</span><br></pre></td></tr></table></figure><p>这里的 error 参数是一个输出参数，它输出的是一个包含错误信息的 NSError 对象。<br>输出参数必须是一个指针，如果不是指针，参数就是值传递，函数对参数的修改无法作用到函数外部。</p><p>那为什么不用一级指针？</p><p>首先先看一下 NSError 这个类的公共属性，会发现都是 readonly 的，也就是说 NSError 是一个不可变对象，它包含的信息在创建对象的时候就确定了，不能再更改。因此这个对象必须由 <code>JSONObjectWithData:options:error:</code> 这个方法内部实现来创建，不能由调用方创建。</p><p>如果这里用一级指针，由于调用方不能创建 NSError 对象，且 Objective-C 不允许在栈上给对象分配内存空间，下面这种写法是不可以的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> error;</span><br><span class="line">[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:&amp;error];</span><br></pre></td></tr></table></figure><p>只能这么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:error];</span><br></pre></td></tr></table></figure><p>这么写的结果是给 error 参数传递了一个 nil 值。于是 <code>JSONObjectWithData:options:error:</code> 的内部实现在创建 NSError 对象时，不知道应该把它创建在哪个地址上，导致调用方也无法接收到这个对象。</p><p>所以下面这种标准写法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:&amp;error];</span><br></pre></td></tr></table></figure><p>的实际含义是：</p><ol><li>在栈上创建了一个指针叫 error，指向的类型是 NSError，并把指针指向的位置初始化为 nil。</li><li>用 <code>&amp;error</code> 获取这个指针本身在栈上的地址，它是有值的，传给 error 参数的值不是 nil。</li><li><code>JSONObjectWithData:options:error:</code> 方法的内部在堆上创建一个 NSError 对象，并把传入的栈上的地址指向这个 NSError 对象。</li><li>调用方就可以通过 error 变量得到这个 NSError 对象了。</li></ol><p>所以这里为什么要用二级指针应该解释清楚了。</p><h1 id="NSError-autoreleasing-中-autoreleasing-修饰符的位置"><a href="#NSError-autoreleasing-中-autoreleasing-修饰符的位置" class="headerlink" title="NSError * __autoreleasing * 中 __autoreleasing 修饰符的位置"></a><code>NSError * __autoreleasing *</code> 中 <code>__autoreleasing</code> 修饰符的位置</h1><p>现在来探索一下 <code>__autoreleasing</code> 修饰符为什么要写在两个星号中间。</p><p>假设定义一个二级指针的变量：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [Cat cat];</span><br><span class="line">Cat **p = &amp;cat;</span><br></pre></td></tr></table></figure><p>如果直接上面这样写，编译器会报错 Pointer to non-const type ‘Cat *’ with no explicit ownership，意思是有一个指针没有显式地指定拥有关系，从这句话来理解，这里的指针是二级指针的内层指针。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [Cat cat];</span><br><span class="line">Cat ** __<span class="keyword">strong</span> p = &amp;cat;</span><br></pre></td></tr></table></figure><p>把代码改成上面代码，编译后依然报相同的错误，所以可以得出结论，在两个星号右边写修饰符，修饰的可能是外层指针。外层指针的具体修饰情况后面再讨论。</p><p>于是把 <code>__strong</code> 往左边移动一个星星。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [Cat cat];</span><br><span class="line">Cat * __<span class="keyword">strong</span> *p = &amp;cat;</span><br></pre></td></tr></table></figure><p>编译通过，可以正常运行。</p><p>再改变 <code>__strong</code> 的位置做几次尝试：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [Cat cat];</span><br><span class="line">Cat __<span class="keyword">strong</span> **p = &amp;cat;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat *cat = [Cat cat];</span><br><span class="line">__<span class="keyword">strong</span> Cat **p = &amp;cat;</span><br></pre></td></tr></table></figure><p>发现都可以正常编译运行，所以：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat * __<span class="keyword">strong</span> *p;</span><br><span class="line">Cat __<span class="keyword">strong</span> **p</span><br><span class="line">__<span class="keyword">strong</span> Cat **p</span><br></pre></td></tr></table></figure><p>这三种写法的效果是一样的，修饰符都是在修饰内层指针。<br>那为什么苹果自己要把 <code>__autoreleasing</code> 写在两个星星中间呢？可能是苹果自己的一种习惯或编码规范吧。</p><p>上面用 <code>__strong</code> 来举例是为了代码简洁，实际上如果要使用 <code>__autoreleasing</code>, cat 本身也要指明是 <code>__autoreleasing</code>。原因应该大家都清楚。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat * __autoreleasing cat = [Cat cat];</span><br><span class="line">Cat * __autoreleasing *p = &amp;cat;</span><br></pre></td></tr></table></figure><h1 id="对于二级指针外层指针的拥有关系的修饰"><a href="#对于二级指针外层指针的拥有关系的修饰" class="headerlink" title="对于二级指针外层指针的拥有关系的修饰"></a>对于二级指针外层指针的拥有关系的修饰</h1><p>那么外层指针的拥有关系，会想到如果是下面的代码会发生什么呢？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cat * __<span class="keyword">strong</span> * __<span class="keyword">weak</span> p = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    Cat *cat = [Cat cat];</span><br><span class="line">    p = &amp;cat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, *p);</span><br></pre></td></tr></table></figure><p>结果打印 (null)，似乎是合理的，weak 指针会在指向的对象释放自动至为 nil。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Cat * __<span class="keyword">strong</span> * __<span class="keyword">strong</span> p = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">    Cat *cat = [Cat cat];</span><br><span class="line">    p = &amp;cat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, *p);</span><br></pre></td></tr></table></figure><p>那么这样呢，运行代码，发现结果还是 (null）。为啥？？？</p><p>其实上面两个代码在运行时编译器都会报出警告，<code>__strong&#39; only applies to Objective-C object or block pointer types; type here is &#39;Cat *__strong *&#39;</code>。意思是说修饰符只支持指向 OC 对象或者 Block 的指针类型。</p><p>二级指针的外层指针（其实就是二级指针本身）指向的是一个指针，并不是 OC 对象或 Block。这里编译器会忽略对外层指针的修饰符，实际上类型还是 <code>Cat * __strong *</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;大家都知道，Objective-C 有 4 个对象所有权修饰符（Ownership Qualifier），分别是：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS 架构小谈</title>
    <link href="https://liuduoios.github.io/ios-architect-discuss/"/>
    <id>https://liuduoios.github.io/ios-architect-discuss/</id>
    <published>2020-02-20T03:56:57.000Z</published>
    <updated>2023-06-05T05:33:26.596Z</updated>
    
    <content type="html"><![CDATA[<p>写了这么多年的 iOS，觉得最佳架构其实就是 MVC，其它什么 MVP、MVVM、VIPER 什么的都是扯淡的，我曾经写过两年多 MVVM，最后感觉就是把简单事情搞复杂了。</p><p>MVC 结构的代码，可读性和可维护性远超其它架构。<br>MVC 架构的学习成本远低于其它架构，新人都能直接上手。</p><p>为啥还有很多人说 MVC 不好，转而去搞其它架构，那是因为他们根本没把 MVC 写好。</p><p>写好 MVC 的第一原则：<strong>界面逻辑和业务逻辑分离</strong><br>写好 MVC 的第二原则：<strong>类的设计严格遵守单一职责原则</strong><br>写好 MVC 的第三原则：<strong>该复用的地方就要复用</strong></p><p>对于界面逻辑和业务逻辑分离，只要把业务逻辑都写在 MVC 的 M 里，界面逻辑都写在 V 和 C 中。</p><p>一个我觉得最完美的 iOS 项目分层方法：<br>主工程：分模块写界面逻辑、资源文件（MVC 中的 V 和 C）<br>工程二：分模块写业务逻辑（MVC 中的 M）<br>工程三：网络和协议层<br>工程四：基础层<br>这四个工程有从上到下的依赖关系，所有工程可以在一个 Workspace 中，工程二到四通过 CocoaPods 来引入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写了这么多年的 iOS，觉得最佳架构其实就是 MVC，其它什么 MVP、MVVM、VIPER 什么的都是扯淡的，我曾经写过两年多 MVVM，最后感觉就是把简单事情搞复杂了。&lt;/p&gt;
&lt;p&gt;MVC 结构的代码，可读性和可维护性远超其它架构。&lt;br&gt;MVC 架构的学习成本远低于</summary>
      
    
    
    
    <category term="架构" scheme="https://liuduoios.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTPS 原理详解</title>
    <link href="https://liuduoios.github.io/https-detail/"/>
    <id>https://liuduoios.github.io/https-detail/</id>
    <published>2018-05-14T01:50:14.000Z</published>
    <updated>2023-06-05T05:33:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要-HTTPS？"><a href="#为什么需要-HTTPS？" class="headerlink" title="为什么需要 HTTPS？"></a>为什么需要 HTTPS？</h1><p>如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 HTTPS 化。那么有了 HTTP 后为什么还需要有 HTTPS 呢？——为了解决 HTTP 的不足。</p><p><strong>HTTP 的不足之处</strong></p><ul><li>通信内容使用明文——内容可能被窃听</li><li>不验证通信方的身份——可能遭遇伪装</li><li>无法验证报文的完整性——报文有可能已遭篡改</li></ul><h1 id="怎样解决-HTTP-的不足之处？"><a href="#怎样解决-HTTP-的不足之处？" class="headerlink" title="怎样解决 HTTP 的不足之处？"></a>怎样解决 HTTP 的不足之处？</h1><h2 id="（一）解决内容为明文问题——加密"><a href="#（一）解决内容为明文问题——加密" class="headerlink" title="（一）解决内容为明文问题——加密"></a>（一）解决内容为明文问题——加密</h2><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p><strong>公开密钥加密（Public-key cryptography）</strong> 是一种具备以下特征的加密方式：</p><ul><li>使用公开的加密算法</li><li>秘钥是保密的</li><li>使用密钥来进行加密和解密</li></ul><p>也就意味着任何人只要得到了密钥，就能进行密钥。秘钥如果泄漏，加密就失去了意义。</p><p>公开密钥加密分为对称密钥加密和非对称密钥加密：</p><h4 id="对称秘钥加密"><a href="#对称秘钥加密" class="headerlink" title="对称秘钥加密"></a>对称秘钥加密</h4><p>加密和解密双方使用同一个密钥的方式叫做<strong>对称密钥加密</strong>。这种方式最大的问题是怎样把密钥安全的从一方发送给另一方，由于网络本身就是不安全的，因此无法保证密钥在发送过程中不会被人截获，任何人只要获得了密钥就能随便解密了。当然也可以不通过网络来发送，比如在线下用 U 盘拷给别人，或者口头告诉别人，在某些场景下这种方式是可以的，但是对于 HTTP 网络请求就无能为力了。</p><h4 id="非对称秘钥加密"><a href="#非对称秘钥加密" class="headerlink" title="非对称秘钥加密"></a>非对称秘钥加密</h4><p>非对称密钥加密解决了密钥在网络上发送的安全问题。非对称秘钥加密使用一对秘钥，一把叫做私有秘钥（private key），另一把叫做公开秘钥（public key）。私钥不能让其他任何人知道，而公钥可以随意发布，任何人都能获得。</p><p>私钥只保管在解密的一方，公钥会被发送给加密的一方。使用这种方式时，发送密文的一方会使用对方公开的公钥对数据进行加密，对方收到加密数据后，再使用自己的私钥进行解密。由于能解密的只有私钥，而私钥不用再网络上发送，因此不用担心被盗走。</p><p>另外，非对称秘钥加密中，攻击者得到了公钥和密文，想破解出原文，就目前的技术来看是非常困难的，因此也保证了数据的安全。</p><h2 id="（二）解决报文完整性问题——数字签名"><a href="#（二）解决报文完整性问题——数字签名" class="headerlink" title="（二）解决报文完整性问题——数字签名"></a>（二）解决报文完整性问题——数字签名</h2><p>数字签名是用来确保数据完整性的技术，它可以证明数据是来自谁，证明数据是否未被篡改过。</p><p>数字签名是附加在数据上的一段特殊的加密过的校验码，使用数字签名有以下几个好处：</p><ol><li>数字签名可以证明数据的作者是谁。因为数字签名是由数据作者用只有作者本人才知道的私钥生成的校验和，因此，这些校验和就像来自于作者的个人“签名”一样。</li><li>数字签名可以防止数据被篡改。如果数据被篡改过，校验和就不匹配了。由于校验和只有作者的保密的私钥才能产生，攻击者在没有私钥的情况下，以目前的技术还无法为篡改后的数据伪造出正确的校验和。</li></ol><p>下面看一下数字签名在网络数据传输中的一个应用流程：</p><p>假设有节点 A 要向节点 B 发送一段报文：</p><ol><li>节点A为要发送的报文生成摘要（例如md5）</li><li>节点A用自己的私钥对摘要执行签名函数生成数字签名</li><li>节点A把数字签名附在要发送的报文之后，然后把报文和签名一块发送给节点B</li><li>节点B收到报文后，先取出数字签名部分，用公钥对签名执行反签名函数得到摘要</li><li>节点B对报文部分生成摘要（例如md5）</li><li>节点B对 4、5 两个步骤得到的两个摘要进行比较</li><li>如果一致，则可以认为报文是未被篡改过的</li></ol><h2 id="（三）解决通信对方可能被伪装的问题——认证"><a href="#（三）解决通信对方可能被伪装的问题——认证" class="headerlink" title="（三）解决通信对方可能被伪装的问题——认证"></a>（三）解决通信对方可能被伪装的问题——认证</h2><p>有了数字签名，就可以验证数据的来源和完整性了，但是仅有数字签名还是有漏洞。使用数字签名进行加密数据传输，数据接收方必须有一个公钥，如果这个公钥被篡改为了攻击者的公钥，那攻击者就可以用自己的私钥发送篡改后的数据了。</p><p>为了保证公钥的真实性，引入了认证这一手段。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>数字证书，有点像生活中的身份证、护照等，是由一个官方的证书颁发机构签发的一组数据。这种证书很难伪造，用于使用者的身份证明。</p><p>数字证书包含以下内容：</p><ul><li>证书格式版本号</li><li>证书序列号</li><li>过期时间</li><li>证书办法机构</li><li>证书使用的签名算法</li><li>过期时间</li><li>对象名称（人、服务器、组织、公司等）</li><li>对象的公开密钥</li><li>其它扩展信息</li><li>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</li><li>附上证书颁发机构的数字签名</li></ul><h3 id="用证书对服务器进行认证："><a href="#用证书对服务器进行认证：" class="headerlink" title="用证书对服务器进行认证："></a>用证书对服务器进行认证：</h3><p>对服务器进行认证时，数字证书中的 <code>对象名称</code> 字段就是服务器的名称和主机名，<code>对象的公开密钥</code> 字段就是服务器的公开密钥。</p><p>客户端或浏览器与服务器通信时会进行如下流程：</p><ol><li>建立 SSL 连接时，服务器会把自己的数字证书下发给客户端&#x2F;浏览器</li><li>客户端&#x2F;浏览器通过证书中 <code>证书颁发机构的数字签名</code> 来验证证书的来源和完整性。一般客户端&#x2F;浏览器会内置一个受信任的证书颁发机构列表。</li><li>一旦证书被认证通过，客户端&#x2F;浏览器就从证书中取出 <code>对象的公开密钥</code>，用这个公钥来加密数据和服务端进行通信了。</li></ol><h1 id="HTTPS-x3D-HTTP-加密-数字签名-认证"><a href="#HTTPS-x3D-HTTP-加密-数字签名-认证" class="headerlink" title="HTTPS &#x3D; HTTP + 加密 + 数字签名 + 认证"></a>HTTPS &#x3D; HTTP + 加密 + 数字签名 + 认证</h1><p>现在来看看 HTTPS 到底是个啥。</p><p>HTTPS &#x3D; HTTP + SSL</p><p>SSL（Secure Sockets Layer，安全套接层），诞生于上世纪 90 年代的网景公司，后来又出现了 SSL 的改进版 TLS（Transport Layer Security，传输层安全协议）。所以目前主要用的是 TLS，不过习惯上还是统一叫做 SSL。SSL 主要内容就是加密、数字签名和认证机制，所以：</p><p>SSL &#x3D; 加密 + 数字签名 + 认证</p><p>因此：HTTPS &#x3D; HTTP + 加密 + 数字签名 + 认证</p><h2 id="SSL-的加密机制"><a href="#SSL-的加密机制" class="headerlink" title="SSL 的加密机制"></a>SSL 的加密机制</h2><p>上面说过了对称秘钥加密和非对称秘钥加密，SSL 的加密是把这两种加密方式混合起来用的。</p><p>由于非对称秘钥加密的性能比对称秘钥加密要慢，只有在建立 SSL 安全连接时，使用非对称秘钥加密，在 SSL 安全连接建立成功后，这时已经能保证通信线路上的数据不会被窃取了，后面都会使用对称秘钥加密。</p><p>建立 SSL 安全连接前：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">客户端--&gt;|非对称密钥加密|服务器</span><br><span class="line">服务器--&gt;|非对称密钥加密|客户端</span><br></pre></td></tr></table></figure><p>建立 SSL 安全连接后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">客户端--&gt;|对称秘钥加密|服务器</span><br><span class="line">服务器--&gt;|对称秘钥加密|客户端</span><br></pre></td></tr></table></figure><h2 id="SSL-的数字签名机制"><a href="#SSL-的数字签名机制" class="headerlink" title="SSL 的数字签名机制"></a>SSL 的数字签名机制</h2><p>SSL 的数字签名和上面说到的数字签名基本一致。就是先通过报文得到摘要，把摘要用自己这边的密钥加密后得到数字签名，对方收到后，取出数字签名用自己的密钥反签名后得到摘要，和通过报文得到的摘要进行比对，如果一致的话就代表验证通过了完整性。</p><h2 id="SSL-的认证技术"><a href="#SSL-的认证技术" class="headerlink" title="SSL 的认证技术"></a>SSL 的认证技术</h2><p>作为服务端想使用 HTTPS，会去官方的正规的证书颁发机构申请证书，需要花点费用。然后服务端会把自己的公钥放在证书里发给服务端，用证书来保证公钥的来源是真实可信的。</p><h1 id="一次完整的-HTTPS-的通信步骤"><a href="#一次完整的-HTTPS-的通信步骤" class="headerlink" title="一次完整的 HTTPS 的通信步骤"></a>一次完整的 HTTPS 的通信步骤</h1><p>步骤 1：客户端向服务器发送 ClientHello 报文，请求建立 SSL 连接。</p><p>ClientHello 报文：</p><ul><li>客户端支持的 SSL 版本</li><li>客户端支持的加密算法</li><li>客户端支持的密钥长度</li></ul><p>步骤 2：服务器收到客户端的请求后，向客户端发送 ServerHello 报文。</p><p>ServerHello 报文：</p><ul><li>决定使用的 SSL 版本</li><li>决定使用的加密算法</li></ul><p>步骤 3：服务器继续发送 Certificate 报文，即服务器的数字证书，其中包含服务器的公开密钥。</p><p>步骤 4：服务器发送 ServerHelloDone 报文，通知客户端进最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5：客户端收到以上所有信息后，发送 ClientKeyExchange 报文作为回应。该报文已使用步骤 3 中的公开密钥加密。其中包含一种称为 Pre-master secret 的随机密码串，用于之后的对称秘钥加密通信。</p><p>步骤 6：客户端继续发送 ChangeCipherSpec 报文，该报文告诉服务器，在此之后的通信都会采用步骤 5 中的 Pre-master secret 秘钥加密。</p><p>步骤 7：客户端发送 Finished 报文。改报文包含连接至今全部报文的整体校验值。</p><p>步骤 8：服务端对客户端报文校验后，同样发送 ChangeCipherSpec 报文，含义与步骤 6 中的相同。</p><p>步骤 9：服务端发送 Finished 报文。</p><p>步骤 10：服务端和客户端的 Finished 报文交换完毕后，SSL 连接建立完成。从此后开始进行应用层协议的通信，即 HTTP 通信。</p><p>步骤 11：HTTP 通信。</p><p>步骤 12：客户端发送 close_notify 报文请求断开连接。之后再发送 TCP FIN 报文来关闭 TCP 通信。</p><h1 id="HTTPS-性能考虑"><a href="#HTTPS-性能考虑" class="headerlink" title="HTTPS 性能考虑"></a>HTTPS 性能考虑</h1><p>从上面的步骤可见，一次 HTTPS 连接会比一次单纯的 HTTP 连接做很多额外的事情。因此 HTTPS 的性能开销是比 HTTP 大很多的。考虑到性能这一块，可以在某些对安全要求比较高的场景使用 HTTPS，比如涉及到钱和支付，在一些对安全要求并不高的场景使用性能更好的 HTTP。</p><p>随着科技的进步，机器的性能越来越好，人们对安全的需求会比性能更加重要，因此安全的 HTTPS 会渐渐的代替 HTTP。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《图解 HTTP》</li><li>《HTTP 权威指南》</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么需要-HTTPS？&quot;&gt;&lt;a href=&quot;#为什么需要-HTTPS？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 HTTPS？&quot;&gt;&lt;/a&gt;为什么需要 HTTPS？&lt;/h1&gt;&lt;p&gt;如今，HTTPS 已经渐渐成为主流，很多大型网站都已经全站 </summary>
      
    
    
    
    <category term="网络" scheme="https://liuduoios.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 pyenv 来管理 Python 版本</title>
    <link href="https://liuduoios.github.io/2018/02/20/%E4%BD%BF%E7%94%A8-pyenv-%E6%9D%A5%E7%AE%A1%E7%90%86-Python-%E7%89%88%E6%9C%AC/"/>
    <id>https://liuduoios.github.io/2018/02/20/%E4%BD%BF%E7%94%A8-pyenv-%E6%9D%A5%E7%AE%A1%E7%90%86-Python-%E7%89%88%E6%9C%AC/</id>
    <published>2018-02-20T14:52:43.000Z</published>
    <updated>2023-06-05T05:33:26.596Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 系统自带的 Python 版本时 2.7.x，最新版本的 Python 是 3.6.x。由于 Python 2 和 Python 3 都需要用到，因此需要一个工具能让电脑中的 Python 可以多版本共存。</p><p>pyenv 是个不错的 Python 版本管理工具。</p><h1 id="安装-pyenv"><a href="#安装-pyenv" class="headerlink" title="安装 pyenv"></a>安装 pyenv</h1><p>在 macOS 上可以使用 Homebrew 来安装 pyenv。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew udpate</span><br><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><p>等 pyenv 安装好了以后，如果用 zsh 的朋友可以把 pyenv 加入到 zshrc 中来实现自动补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  ...</span><br><span class="line">  pyenv</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h1><p>用下面命令来查看所有可以安装的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure><p>安装 Python 的指定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install [版本号]</span><br></pre></td></tr></table></figure><p>例如写此文时 Python 的最新稳定版为 3.6.4，则为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.6.4</span><br></pre></td></tr></table></figure><h1 id="切换-Python-版本"><a href="#切换-Python-版本" class="headerlink" title="切换 Python 版本"></a>切换 Python 版本</h1><p>可以通过下面命令来查看本地已经安装的所有 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br></pre></td></tr></table></figure><p>用 pyenv local 来切换本地当前使用的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> 3.6.4</span><br></pre></td></tr></table></figure><p>然后查看当前使用的 Python 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>如果是 3.6.4 则说明已经切换成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;macOS 系统自带的 Python 版本时 2.7.x，最新版本的 Python 是 3.6.x。由于 Python 2 和 Python 3 都需要用到，因此需要一个工具能让电脑中的 Python 可以多版本共存。&lt;/p&gt;
&lt;p&gt;pyenv 是个不错的 Python 版</summary>
      
    
    
    
    <category term="Python" scheme="https://liuduoios.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>分析 Block 的实现方式</title>
    <link href="https://liuduoios.github.io/block-impl/"/>
    <id>https://liuduoios.github.io/block-impl/</id>
    <published>2018-02-19T10:23:01.000Z</published>
    <updated>2023-06-05T05:33:26.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过-clang-来研究-Block-的实现"><a href="#通过-clang-来研究-Block-的实现" class="headerlink" title="通过 clang 来研究 Block 的实现"></a>通过 clang 来研究 Block 的实现</h1><p>clang 是 Objective-C 的编译器前端，用它可以将 Objective-C 代码转换为 C&#x2F;C++ 代码，然后可以来分析 Objective-C 中的一些特性是怎么实现的。</p><p>首先创建一个命令行应用程序，在 main.m 中，修改 main 函数的内容：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">void</span> (^task)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    task();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面代码用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure><p>可以在 main.cpp 中找到生成后的代码，可以看到生成后的 main 函数是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*task)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">    ((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)task)-&gt;FuncPtr)((__block_impl *)task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Block-的内存布局和创建过程"><a href="#Block-的内存布局和创建过程" class="headerlink" title="Block 的内存布局和创建过程"></a>Block 的内存布局和创建过程</h1><p>先看第一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*task)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>&#x3D; 号左边是声明了一个名为 task 的函数指针。<br>&#x3D; 号右边创建了一个 <code>__main_block_impl_0</code> 类型的结构体，并通过 <code>__main_block_impl_0</code> 的初始化函数来初始化，简写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA)</span><br></pre></td></tr></table></figure><p>第一个参数是 <code>__main_block_func_0</code> 指针，第二个参数取了 __main_block_desc_0_DATA 的地址。</p><p>现在再看看 <code>__main_block_func_0</code> 是什么：</p><p>生成的代码中 <code>__main_block_func_0</code> 的定义如下，是一个静态全局函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它有一个名为 __cself 的参数，是一个 __main_block_impl_0 结构体类型的指针。</p><p>于是我们继续来看 __main_block_impl_0 结构体，它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它拥有两个成员变量，impl 和 Desc，还带有一个初始化函数。impl 的类型为 __block_impl 结构体，可以找到它的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__block_impt 就是 Block <strong>背后的数据结构</strong>：</p><ul><li>isa 字段代表 block 对象是由哪一个类实例化来的。  </li><li>Flags 标识符。  </li><li>Reserved 是为未来保留的字段。  </li><li>FuncPtr 是一个函数指针。</li></ul><p>再看看 __main_block_impl_0 结构体的另一个成员变量 Desc，是一个 __main_block_desc_0 结构体类型的指针。</p><p>在生成的代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>__main_block_desc_0 有两个字段，一个保留字段 reserved，和一个保存 Block 占用内存大小的字段 Block_size。并且同时创建了一个 __main_block_desc_0_DATA 的变量，初始化为 <code>&#123; 0, sizeof(struct __main_block_impl_0) &#125;</code>。</p><p>通过 <code>__main_block_impl_0</code> 的定义可知，<code>__main_block_impl_0</code> 的初始化方法的第一个参数是一个函数指针。再回到 main 函数中，在初始化 _main_block_impl_0 时，可以看到传入的函数指针为 <code>__main_block_func_0</code>，因此 Block 在调用的时候就是调用的 <code>__main_block_func_0</code> 这个函数。<code>__main_block_func_0</code> 函数接收一个参数 <code>__cself</code>，也是 __main_block_impl_0 结构体类型的指针，它代表这个 Block 自身。</p><p>__main_block_impl_0 初始化函数的第二个参数则传入了 __main_block_desc_0_DATA 变量，它的 reserved 变量为 0，Block_size 为 __main_block_impl_0 的大小。</p><p>再回到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*task)(<span class="type">void</span>) = ((<span class="built_in">void</span> (*)())&amp;__main_block_impl_0((<span class="type">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>可以看到创建好的 <code>__main_block_impl_0</code> 结构体，通过 &amp; 操作符获取了它的地址，然后转换为 void (*)() 这个函数指针类型，最后赋值给 task 这个函数指针。</p><p>通过分析 main 函数的第一行代码，大概知道了 Block 在内存中的布局是什么样的，也知道了 Block 的创建过程，现在来看看 Block 是怎么被调用的。</p><h1 id="Block-的调用过程"><a href="#Block-的调用过程" class="headerlink" title="Block 的调用过程"></a>Block 的调用过程</h1><p>现在开始研究 main 函数的第二行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">void</span> (*)(__block_impl *))((__block_impl *)task)-&gt;FuncPtr)((__block_impl *)task);</span><br></pre></td></tr></table></figure><p>由于代码中涉及到很多类型强转，看上去比较乱，把它分解如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__block_impl *taskImpl = (__block_impl *)task;</span><br><span class="line"><span class="built_in">void</span> (*func)(__block_impl *) = (<span class="built_in">void</span> (*)(__block_impl *))(taskImpl-&gt;FuncPtr);</span><br><span class="line"><span class="built_in">func</span>(taskImpl);</span><br></pre></td></tr></table></figure><p>可见 Block 的调用就是通过 <code>__block_impl</code> 中的函数指针 FuncPtr 来调用函数。Block 的调用就是函数的调用。</p><p>通过上面的分析可知，FuncPtr 指向的函数为 <code>__main_block_func_0</code>，上面的例子中 <code>__main_block_func_0</code> 函数的内容为空，现在给 Block 中添加一句代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">void</span> (^task)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    task();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>clang -rewrite-objc main.m</code> 重新生成后，会发现 __main_block_func_0 函数的内容就是 Block 的内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 Block 的调用就是函数的调用。</p><h1 id="Block-截获自动变量"><a href="#Block-截获自动变量" class="headerlink" title="Block 截获自动变量"></a>Block 截获自动变量</h1><p>现在来看看 Block 截获自动变量是怎么实现的，把 OC main 函数中的代码改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> (^task)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        printf(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    task();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看生成的代码，会发现 <code>__main_block_impl_0</code> 中增加了一个成员变量 i：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// 增加了一个成员变量 i</span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> _i, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">i</span>(_i) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>__main_block_impl_0</code> 也增加了 _i 参数用于初始化 i 变量。这里的 i 的初始化时值传递的，因此 i 是保存了 Block 外面的变量 i 的值的副本。</p><p>再看看 Block 截获对象的情况，把 main 函数改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> (^task)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, object);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    task();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代码中的 <code>__main_block_impl_0</code> 同样是增加了一个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  NSObject *object; <span class="comment">// </span></span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, NSObject *_object, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="built_in">object</span>(_object) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于这里 _object 也是一个 Block 外 object 对象的指针的复制值，同样无法用 Block 中保存的 object 来修改 Block 外的 object 的值。</p><h1 id="block-的实现"><a href="#block-的实现" class="headerlink" title="__block 的实现"></a>__block 的实现</h1><p>未完待续。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过-clang-来研究-Block-的实现&quot;&gt;&lt;a href=&quot;#通过-clang-来研究-Block-的实现&quot; class=&quot;headerlink&quot; title=&quot;通过 clang 来研究 Block 的实现&quot;&gt;&lt;/a&gt;通过 clang 来研究 Block 的</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>C 指针和 id 的转换，理解 Toll-Free Bridge</title>
    <link href="https://liuduoios.github.io/toll-free-bridge/"/>
    <id>https://liuduoios.github.io/toll-free-bridge/</id>
    <published>2018-02-17T14:23:06.000Z</published>
    <updated>2023-06-05T05:33:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="id-和-void-类型的相互转换"><a href="#id-和-void-类型的相互转换" class="headerlink" title="id 和 void * 类型的相互转换"></a>id 和 void * 类型的相互转换</h1><h2 id="bridge"><a href="#bridge" class="headerlink" title="__bridge"></a>__bridge</h2><p>通过 <code>__bridge</code> 桥接，id 和 void * 就能够相互转换。__bridge 为直接转换，不会对引用计数做特殊处理。</p><p><code>__bridge</code> 转换其的安全性与赋值给 __unsafe_unretained 修饰符相近，甚至会更低。如果管理不注意赋值对象的所有者，就会因<strong>野指针</strong>而导致程序崩溃。</p><h2 id="bridge-retained"><a href="#bridge-retained" class="headerlink" title="__bridge_retained"></a>__bridge_retained</h2><p>__bridge_retained 转换可以使要转换赋值的变量也持有所赋值的对象。</p><p>等价于 MRC 的如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="type">void</span> *p = obj;</span><br><span class="line">[(<span class="type">id</span>)p <span class="keyword">retain</span>];</span><br></pre></td></tr></table></figure><p>看下面代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    p = (__bridge_retained <span class="type">void</span> *)(obj); <span class="comment">// p 持有 obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;class = %@&quot;</span>, [(__bridge <span class="type">id</span>)p <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure><p>在大括号外打印 p 的 class，结果为 NSObject，因此 obj 在大括号结束后没有被释放，p 持有了 obj。</p><h2 id="bridge-transfer"><a href="#bridge-transfer" class="headerlink" title="__bridge_transfer"></a>__bridge_transfer</h2><p>__bridge_transfer 提供与 __bridge_retained 相反的动作，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> obj = (__bridge_transfer <span class="type">id</span>)p;</span><br></pre></td></tr></table></figure><p>等价于 MRC 的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> obj = (<span class="type">id</span>)p;</span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line">[(<span class="type">id</span>)p release];</span><br></pre></td></tr></table></figure><h1 id="用-Bridge-来管理-Objective-C-对象的内存"><a href="#用-Bridge-来管理-Objective-C-对象的内存" class="headerlink" title="用 Bridge 来管理 Objective-C 对象的内存"></a>用 Bridge 来管理 Objective-C 对象的内存</h1><p><code>__bridge_retained</code> 转换与 retain 类似，<code>__bridge_transfer</code> 转换与 release 类似。使用这两种转换，在不使用 id 类型或对象型变量时，也可以生成、持有以及释放对象。</p><p>例如可以使用 Bridge 来对 Objective-C 对象进行内存管理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并持有对象</span></span><br><span class="line"><span class="type">void</span> *p = (__bridge_retained <span class="type">void</span> *)[[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对象</span></span><br><span class="line">(<span class="type">void</span>)(__bridge_transfer <span class="type">id</span>)p;</span><br></pre></td></tr></table></figure><p>只是这种写法不会有人这样写。</p><h1 id="Objective-C-对象和-Core-Foundation-对象之间的转换"><a href="#Objective-C-对象和-Core-Foundation-对象之间的转换" class="headerlink" title="Objective-C 对象和 Core Foundation 对象之间的转换"></a>Objective-C 对象和 Core Foundation 对象之间的转换</h1><p>Objective-C 对象和 Core Foundation 对象之间的区别很小，不同之处只在于是由哪个框架生成的（Foundation 和 Core Foundation）。Foundation 框架生成并持有的对象可以用 Core Foundation 框架 API 释放，反之亦可。</p><p>Objective-C 对象和 Core Foundation 对象之间的转换不需要消耗额外的 CPU 资源，因此成为免费桥（Toll-Free Bridge）。</p><p>也可以调用内置函数来进行 Objective-C 对象和 Core Foundation 对象之间的转换。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="type">id</span> X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">id</span> <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFTypeRef</span> X) &#123;</span><br><span class="line">    <span class="keyword">return</span> (__bridge_transfer <span class="type">id</span>)X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数的效果跟直接使用关键字 __bridge_retained 和 __bridge_transfer 的效果是一样的。</p><h1 id="避免出现野指针"><a href="#避免出现野指针" class="headerlink" title="避免出现野指针"></a>避免出现野指针</h1><p>看下面例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    cfObject = (__bridge <span class="built_in">CFMutableArrayRef</span>)obj;</span><br><span class="line">    <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">    printf(<span class="string">&quot;retain count = %d\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;retain count = %d\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure><p>以上代码在运行时会崩溃，因为 cfObject 在大括号内被赋值，使用 __bridge 关键字时，cfObject 是不持有 obj 的，当出大括号后，obj 被释放，cfObject 也就成野指针的，导致崩溃。</p><p>这时需要改为 __bridge_retained 或 CFBridingRetain。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    cfObject = <span class="built_in">CFBridgingRetain</span>(obj); <span class="comment">// 改动这行代码</span></span><br><span class="line">    <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">    printf(<span class="string">&quot;retain count = %d\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">&quot;retain count = %d\n&quot;</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;id-和-void-类型的相互转换&quot;&gt;&lt;a href=&quot;#id-和-void-类型的相互转换&quot; class=&quot;headerlink&quot; title=&quot;id 和 void * 类型的相互转换&quot;&gt;&lt;/a&gt;id 和 void * 类型的相互转换&lt;/h1&gt;&lt;h2 id=&quot;b</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD 中那些你可能不熟悉的知识</title>
    <link href="https://liuduoios.github.io/gcd-maybe-you-dont-know/"/>
    <id>https://liuduoios.github.io/gcd-maybe-you-dont-know/</id>
    <published>2018-02-17T09:13:13.000Z</published>
    <updated>2023-06-05T05:33:26.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dispatch-get-global-queue-的参数的含义"><a href="#dispatch-get-global-queue-的参数的含义" class="headerlink" title="dispatch_get_global_queue 的参数的含义"></a>dispatch_get_global_queue 的参数的含义</h1><p>dispatch_get_global_queue 用来从 GCD 的全局队列池中获取一个全局的队列。</p><p>全局队列都是并发队列。</p><h2 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h2><p>第一个参数在 iOS 7 及更低版本上表示优先级，有四种取值，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure><p>在 iOS 8 及更高版本上表示服务质量（QoS），有六种取值，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__QOS_ENUM(qos_class, <span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">QOS_CLASS_USER_INTERACTIVE</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x21</span>,</span><br><span class="line">QOS_CLASS_USER_INITIATED</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x19</span>,</span><br><span class="line">QOS_CLASS_DEFAULT</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x15</span>,</span><br><span class="line">QOS_CLASS_UTILITY</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x11</span>,</span><br><span class="line">QOS_CLASS_BACKGROUND</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x09</span>,</span><br><span class="line">QOS_CLASS_UNSPECIFIED</span><br><span class="line">__QOS_CLASS_AVAILABLE(macos(<span class="number">10.10</span>), ios(<span class="number">8.0</span>)) = <span class="number">0x00</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>DISPATCH_QUEUE_PRIORITY_HIGH 和 QOS_CLASS_USER_INTERACTIVE 都是最高的优先级。</p><p>DISPATCH_QUEUE_PRIORITY_BACKGROUND 和 QOS_CLASS_BACKGROUND 的优先级非常低，一般不用，因为使用此优先级的任务很难被调度到。</p><p>如果需要兼容 iOS 7 和 iOS 8，可以往第一个参数中传入 0，在 iOS 7 中 0 是 DISPATCH_QUEUE_PRIORITY_DEFAULT 的取值，在 iOS 8 中，0 是 QOS_CLASS_UNSPECIFIED 的取值，所以都不会有问题。</p><h2 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h2><p>第二个参数是苹果设计用来给未来做扩展用的，目前没有任何作用，开发中都是传入 0 即可。</p><h1 id="dispatch-queue-create-的参数的含义"><a href="#dispatch-queue-create-的参数的含义" class="headerlink" title="dispatch_queue_create 的参数的含义"></a>dispatch_queue_create 的参数的含义</h1><p>dispatch_queue_create 用来自己创建一个串行队列或并发队列。</p><h2 id="第一个参数-1"><a href="#第一个参数-1" class="headerlink" title="第一个参数"></a>第一个参数</h2><p>第一个参数是队列名称，队列名称可以用来在 debug 或性能调优时在调用栈中显示队列名称，或者在 crash 日志中显示当前队列名，来帮助定位问题。通过查看系统创建的队列的命名方式，会发现苹果一般是用<strong>反域名</strong>风格来命名队列的。</p><h2 id="第二个参数-1"><a href="#第二个参数-1" class="headerlink" title="第二个参数"></a>第二个参数</h2><p>第二个参数应该不陌生，就是传入 DISPATCH_QUEUE_SERIAL 来创建串行队列，传入 DISPATCH_QUEUE_CONCURRENT 来创建并发队列，也可以传入 NULL 这时也代表创建串行队列。</p><h1 id="在队列中储存上下文信息"><a href="#在队列中储存上下文信息" class="headerlink" title="在队列中储存上下文信息"></a>在队列中储存上下文信息</h1><p>可以通过 dispatch_set_context 和 dispatch_get_context 来保存和获取自定义的上下文信息。dispatch_set_context 的参数是 void * 类型，可以传入任何 Objective-C 对象或者其它 C 指针类型等。</p><h1 id="给队列设置-Finalizer-Function-来清除上下文信息"><a href="#给队列设置-Finalizer-Function-来清除上下文信息" class="headerlink" title="给队列设置 Finalizer Function 来清除上下文信息"></a>给队列设置 Finalizer Function 来清除上下文信息</h1><p>队列的 Finalizer Function 会在队列销毁前调用，用 dispatch_set_finalizer_f 函数来给队列设置 Finalizer Function。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> myFinalizerFunction(<span class="type">void</span> *context) &#123;</span><br><span class="line">    MyDataContext *dataContext = (__bridge MyDataContext *)context;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除上下文中的数据</span></span><br><span class="line">    [dataContext clean];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> createMyQueue() &#123;</span><br><span class="line">    MyDataContext *context = [[MyDataContext alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">&quot;com.example.TaskQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dispatch_set_context(serialQueue, (__bridge <span class="type">void</span> *)(context));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 Finalizer Function</span></span><br><span class="line">    dispatch_set_finalizer_f(serialQueue, &amp;myFinalizerFunction);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> serialQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dispatch-async-和-dispatch-sync-的区别"><a href="#dispatch-async-和-dispatch-sync-的区别" class="headerlink" title="dispatch_async 和 dispatch_sync 的区别"></a>dispatch_async 和 dispatch_sync 的区别</h1><table><thead><tr><th>函数</th><th>区别</th></tr></thead><tbody><tr><td>dispatch_async</td><td>1. 会从线程池拿新线程并在新线程上执行任务。 <br />2. 函数本身会立刻返回，继续执行后续代码。</td></tr><tr><td>dispatch_sync</td><td>1. 不会拿新线程，在当前线程上执行任务。<br />2. 函数本身会阻塞其它代码在当前线程上的执行，等到 Block 执行完成后，函数才会返回，继续执行后续代码。</td></tr></tbody></table><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>对于串行队列，dispatch_sync 的调用方所在队列如果和 dispatch_sync 的第一个参数是同一个队列，就会造成死锁。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)deadlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.example.deadlock&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;这里 %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;这里2 %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;come here&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会发生死锁，同样的，在主队列中 dispatch_sync 也会死锁：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)deadlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;这里 1 %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;这里 2 %@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dispatch-suspend-和-dispatch-resume"><a href="#dispatch-suspend-和-dispatch-resume" class="headerlink" title="dispatch_suspend 和 dispatch_resume"></a>dispatch_suspend 和 dispatch_resume</h1><p>dispatch_suspend 挂起指定的队列，这时队列中的 task 会停止执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(queue);</span><br></pre></td></tr></table></figure><p>dispatch_resume 恢复被挂起的指定队列，让队列中的任务继续执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure><p>这两个函数对应执行的或者正在执行的处理没有影响，只对追加到 Dispatch Queue 中但是尚未执行的处理有影响。</p><h1 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h1><h2 id="作用1：变更队列优先级"><a href="#作用1：变更队列优先级" class="headerlink" title="作用1：变更队列优先级"></a>作用1：变更队列优先级</h2><p>自己创建的队列可以指定优先级，但是全局队列的优先级总是默认的，可以通过 dispatch_set_target_queue 来改变全局队列的优先级。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure><p>第一个参数：<br>指定要被变更优先级的队列</p><p>第二个参数：<br>指定一个队列，会把这个队列的优先级指定给第一个参数中的队列</p><h2 id="作用2：让多个串行队列之间也能串行地执行任务"><a href="#作用2：让多个串行队列之间也能串行地执行任务" class="headerlink" title="作用2：让多个串行队列之间也能串行地执行任务"></a>作用2：让多个串行队列之间也能串行地执行任务</h2><p>如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p><p>在必须将不可并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。</p><p>以下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue1 = dispatch_queue_create(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue1&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue2 = dispatch_queue_create(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue3 = dispatch_queue_create(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue3&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> targetDispatchQueue = dispatch_queue_create(<span class="string">&quot;com.example.gcd.TargetDispatchQueue&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue1, targetDispatchQueue);</span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue2, targetDispatchQueue);</span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue3, targetDispatchQueue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(mySerialDispatchQueue1, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;mySerialDispatchQueue1 %@ %@&quot;</span>, @(i), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(mySerialDispatchQueue2, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;mySerialDispatchQueue2 %@ %@&quot;</span>, @(i), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(mySerialDispatchQueue3, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;mySerialDispatchQueue3 %@ %@&quot;</span>, @(i), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>的执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">2018-02-17 15:20:21.140237+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 0 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140383+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 1 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140470+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 2 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140588+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 3 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140672+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 4 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140751+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 5 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140834+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 6 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.140926+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 7 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.141006+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 8 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.141089+0800 GCDStudy[1509:141116] mySerialDispatchQueue1 9 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.141199+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 0 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143468+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 1 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143552+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 2 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143645+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 3 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143728+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 4 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143805+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 5 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143870+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 6 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.143940+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 7 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144002+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 8 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144067+0800 GCDStudy[1509:141116] mySerialDispatchQueue2 9 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144175+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 0 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144267+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 1 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144338+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 2 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144409+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 3 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144489+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 4 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144580+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 5 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144709+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 6 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144838+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 7 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.144971+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 8 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:20:21.145078+0800 GCDStudy[1509:141116] mySerialDispatchQueue3 9 &lt;NSThread: 0x608000469840&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure><h1 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h1><p>该函数按指定的次数将指定的 Block 追加到指定的 Dispatch Queue 中，并<strong>等待全部处理执行结束</strong>。</p><p>例如下面代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu %@&quot;</span>, index, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;done&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2018-02-17 15:43:41.665070+0800 GCDStudy[1731:166365] 5 &lt;NSThread: 0x60c000079c40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665065+0800 GCDStudy[1731:166331] 3 &lt;NSThread: 0x604000075a40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2018-02-17 15:43:41.665073+0800 GCDStudy[1731:166367] 1 &lt;NSThread: 0x60000046d300&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665073+0800 GCDStudy[1731:166402] 7 &lt;NSThread: 0x60c0000799c0&gt;&#123;number = 9, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665073+0800 GCDStudy[1731:166366] 4 &lt;NSThread: 0x60000046d680&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665079+0800 GCDStudy[1731:166379] 0 &lt;NSThread: 0x60400007b0c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665094+0800 GCDStudy[1731:166368] 2 &lt;NSThread: 0x60400007b480&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665095+0800 GCDStudy[1731:166401] 6 &lt;NSThread: 0x604000079cc0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665218+0800 GCDStudy[1731:166331] 8 &lt;NSThread: 0x604000075a40&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2018-02-17 15:43:41.665220+0800 GCDStudy[1731:166367] 9 &lt;NSThread: 0x60000046d300&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018-02-17 15:43:41.665643+0800 GCDStudy[1731:166331] done</span><br></pre></td></tr></table></figure><p>每一次打印都是并发执行的，并且 done 一定会在最后打印。</p><h2 id="实例：不需要关心顺序，遍历并处理-NSArray-的所有元素"><a href="#实例：不需要关心顺序，遍历并处理-NSArray-的所有元素" class="headerlink" title="实例：不需要关心顺序，遍历并处理 NSArray 的所有元素"></a>实例：不需要关心顺序，遍历并处理 NSArray 的所有元素</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>, @<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(array.count, queue, ^(size_t index) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu: %@&quot;</span>, index, array[index]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在不需要关心顺序的情况下，可以用 dispatch_apply 来遍历 NSArray，NSDictionary，NSSet 等，这种方式执行效率比直接循环遍历要高，但是可能更费电（因为要开辟和切换线程）。</p><p>由于 dispatch_apply 会阻塞当前线程，可以根据需要在 dispatch_async 中执行 dispatch_apply，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>, @<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    dispatch_apply(array.count, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu: %@&quot;</span>, index, array[index]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;done&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dispatch-apply-的实现方式"><a href="#dispatch-apply-的实现方式" class="headerlink" title="dispatch_apply 的实现方式"></a>dispatch_apply 的实现方式</h2><p>dispatch_apply 其内部是结合了 dispatch_sync 和 Dispatch Group 的调用来实现的。</p><h1 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h1><p>Dispatch Semaphore 是持有计数的信号量。</p><p>dispatch_semaphore_create 创建一个信号量，并通过参数指定信号量持有的计数。</p><p>dispatch_semaphore_signal 将信号量持有计数增加 1。</p><p>dispatch_semaphore_wait 函数会判断信号量持有计数的值，如果计数为 1 或大于 1，函数会直接返回。<br>如果计数为 0，函数会阻塞当前线程并一直处于等待状态不返回，直到信号量计数变为大于等于 1，dispatch_semaphore_wait 才会停止等待并返回。<br>dispatch_semaphore_wait 支持设置一个等待时间，如果到了这个时间，即使信号量计数不是大于等于 1，函数也会停止等待并返回。</p><h2 id="实例1：让函数阻塞地执行异步任务"><a href="#实例1：让函数阻塞地执行异步任务" class="headerlink" title="实例1：让函数阻塞地执行异步任务"></a>实例1：让函数阻塞地执行异步任务</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)dispatchSemaphoreDemo &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;com.example.GCD.dispatchSemaphore&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;here 1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), queue, ^&#123;</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;here 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数在执行过程是会先打印 here 1，然后阻塞住当前线程 1 秒钟，然后打印 here 2，然后函数返回，调用结束。</p><h2 id="实例2：细粒度地控制在同一时间一个操作可以被并发得执行次数"><a href="#实例2：细粒度地控制在同一时间一个操作可以被并发得执行次数" class="headerlink" title="实例2：细粒度地控制在同一时间一个操作可以被并发得执行次数"></a>实例2：细粒度地控制在同一时间一个操作可以被并发得执行次数</h2><p>下面代码并发的、不考虑顺序地给 NSArray 添加对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        [array addObject:@(i)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面代码会有很大概率发生崩溃，因为并发的执行很容易发生内存错误。</p><p>这时可以用 Dispatch Semaphore 来细粒度地控制同一时间的并发执行次数。把上面代码改为以下代码即可避免发生崩溃。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        [array addObject:@(i)];</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中用 <code>dispatch_semaphore_create(1)</code> 创建了一个持有计数为 1 信号量 semaphore。然后把具体要限制并发次数的操作用一对 dispatch_semaphore_wait 和 dispatch_semaphore_signal 包含在其中。这样避免了 addObject 在同时多次并发执行时可能出现的问题。</p><p>dispatch_semaphore_wait 有返回值，上面代码也可以这么写，效果是一样的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="type">long</span> result = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            [array addObject:@(i)];</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dispatch-get-global-queue-的参数的含义&quot;&gt;&lt;a href=&quot;#dispatch-get-global-queue-的参数的含义&quot; class=&quot;headerlink&quot; title=&quot;dispatch_get_global_queue 的参</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
    <category term="多线程" scheme="https://liuduoios.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 原子属性</title>
    <link href="https://liuduoios.github.io/objective-c-atomic/"/>
    <id>https://liuduoios.github.io/objective-c-atomic/</id>
    <published>2018-02-08T05:04:34.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 在声明一个属性的时候，想必大家都是不用经过大脑思考就会写 <code>@property (nonatomic, ...</code>。</p><p>我们都知道属性可以是 nonatomic 也可以使 atomic 的，但是好像几乎所有属性在声明的时候 nonatomic，atomic 的属性几乎没出现过。atomic 修饰符仿佛已被大家遗忘。</p><p>实际上，如果声明属性时既不写 atomic 也不写 nonatomic，那么这个属性<strong>默认是 atomic 的</strong>。</p><h3 id="atomic-的作用和工作原理"><a href="#atomic-的作用和工作原理" class="headerlink" title="atomic 的作用和工作原理"></a>atomic 的作用和工作原理</h3><p>从字面上来看 nonatomic 是非原子的，atomic 是原子的。</p><p>atomic 的作用为：</p><blockquote><p>atomic 修饰的属性的写操作是一个原子操作。</p></blockquote><p><strong>什么是原子操作？</strong></p><p>原子操作就是指不会被线程调度机制打断的操作。这个操作是一个整体，CPU 一旦开始执行它，就会一直到执行结束，在这期间 CPU 不会转而去执行其它线程的操作。</p><p>可以用代码来模拟一下 atomic 的工作原理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> count;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> count = _count;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setCount:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _count = count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看上面代码，ViewController 有个 count 属性，我们重写了它的 Setter 和 Getter 方法，在 Setter 方法中，通过 <code>@synchronized (self) &#123;&#125;</code> 为复制操作 <code>_count = count</code> 加了一把锁，使得赋值这个操作同一时间只能有一个线程执行，保证了写属性值的时候的线程安全。</p><p>上面代码实现了和 atomic 相同的功能，但是底层的工作方式还是有区别的。我们常常用 <code>@synchronized</code> 来加锁，这种锁是<strong>互斥锁</strong>。而 atomic 修饰的属性自带了一把<strong>自旋锁</strong>。</p><p><strong>互斥锁和自旋锁的区别：</strong></p><table><thead><tr><th>锁名</th><th>作用</th></tr></thead><tbody><tr><td>互斥锁</td><td>当某个资源被先进入的线程上了锁以后，其它后面进入的线程会<strong>进入休眠状态</strong>。当锁释放后，进入休眠状态的线程变为唤醒状态。</td></tr><tr><td>自旋锁</td><td>当某个资源被先进入的线程上了锁以后，其它后进入的线程会开启一个<strong>循环</strong>，不断检查锁有没有释放，当锁释放后，退出循环开始访问资源，整个过程中后进入的线程一直<strong>保持运行状态</strong>。</td></tr></tbody></table><h3 id="大多数情况下，atomic-并不能保证线程安全"><a href="#大多数情况下，atomic-并不能保证线程安全" class="headerlink" title="大多数情况下，atomic 并不能保证线程安全"></a>大多数情况下，atomic 并不能保证线程安全</h3><p>既然 atomic 能简单的让一个属性的写操作变成线程安全的，为什么几乎不用它？</p><p>下面看一个简单的例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> count;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *threadA = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br><span class="line">    [threadA start];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *threadB = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br><span class="line">    [threadB start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)doSomething &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">self</span>.count++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self.count = %@ %@&quot;</span>, @(<span class="keyword">self</span>.count), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面代码中，把属性 count 声明为 atomic 的。在 viewDidLoad 中创建了两个线程 threadA 和 threadB，都去执行 doSomething 方法。在 doSomething 方法中，去给 self.count 的值通过每次循环 +1 增加 10 次，然后打印 self.count 的值。为了让异常情况出现的概率提高，加入一句 <code>[NSThread sleepForTimeInterval:1.0];</code>。</p><p>运行上面的代码，会发现打印的结果中，最后一条 self.count 的值往往是小于 20 的，在中间的某些打印日志中，会发现有些数字被重复打印的两次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">2018-02-07 23:05:08.718744+0800 AtomicDemo[53388:2777211] self.count = 13 &lt;NSThread: 0x600000265f40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018-02-07 23:05:08.718791+0800 AtomicDemo[53388:2777210] self.count = 14 &lt;NSThread: 0x600000265f00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-07 23:05:09.719374+0800 AtomicDemo[53388:2777210] self.count = 15 &lt;NSThread: 0x600000265f00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2018-02-07 23:05:09.719374+0800 AtomicDemo[53388:2777211] self.count = 15 &lt;NSThread: 0x600000265f40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018-02-07 23:05:10.719673+0800 AtomicDemo[53388:2777211] self.count = 17 &lt;NSThread: 0x600000265f40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">2018-02-07 23:05:10.719673+0800 AtomicDemo[53388:2777210] self.count = 16 &lt;NSThread: 0x600000265f00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的结果中 15 出现了两次，这说明在使用 atomic 的情况下，还是出现了资源竞争。</p><p>那么原因在哪里呢？</p><p>我们看这句代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.count++;</span><br></pre></td></tr></table></figure><p>这句代码做了两件事，先读取 self.count 的值，然后把读取到的值 + 1 后赋值给 self.count。</p><p>由于 atomic 仅仅能保证写是线程安全的，而不是保证 读 -&gt; +1 -&gt; 写，这个整体是线程安全的。</p><p>当两个线程都执行到读取完 self.count 的值后，再去写，就会写成一样的值。</p><p>所以大部分情况下，为了保证线程安全，还是要自己加锁，可以根据需要来保证某块代码整体的线程安全。</p><p>线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)doSomething &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>];</span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;self.count = %@ %@&quot;</span>, @(<span class="keyword">self</span>.count), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 atomic 在大部分情况下都无法保证线程安全，并且 atomic 的属性因为增加了原子性而降低了执行效率，因此实际开发中几乎不会出现 atomic 的身影。</p><h3 id="nonatomic-对比-atomic"><a href="#nonatomic-对比-atomic" class="headerlink" title="nonatomic 对比 atomic"></a>nonatomic 对比 atomic</h3><p>最后简单对比一下 nonatomic 和 atomic</p><table><thead><tr><th>修饰符</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>nonatomic</td><td>执行效率高，性能好</td><td>不是线程安全的</td></tr><tr><td>atomic</td><td>线程安全，但是仅能保证写操作的线程安全</td><td>大幅降低执行效率</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Objective-C 在声明一个属性的时候，想必大家都是不用经过大脑思考就会写 &lt;code&gt;@property (nonatomic, ...&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们都知道属性可以是 nonatomic 也可以使 atomic 的，但是好像几乎所有属性在声明的</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Runtime 自己动手实现 KVO —— 探究 KVO 的底层实现</title>
    <link href="https://liuduoios.github.io/kvo-imp/"/>
    <id>https://liuduoios.github.io/kvo-imp/</id>
    <published>2018-02-07T02:51:40.000Z</published>
    <updated>2023-06-05T05:33:26.598Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO-的实现原理"><a href="#KVO-的实现原理" class="headerlink" title="KVO 的实现原理"></a>KVO 的实现原理</h3><p>在 Objective-C 中，用 KVO 可以很方便的观察某个属性的值的变化，一有变化可以立刻响应，虽然滥用 KVO 容易踩坑，但是在很多情形下，KVO 还是很好用的。接下来我们来看一看 KVO 是怎么实现的。</p><p>我们来写一个例子来研究，创建一个 Simple App 项目，首先写一个 Bird 类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bird</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.m</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Bird</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 ViewController.m 中，添加如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Bird.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *b;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    Bird *b = [[Bird alloc] init];</span><br><span class="line">    [b addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;name = %@&quot;</span>, <span class="keyword">self</span>.b.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">self</span>.b.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, @(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行程序，每次点击屏幕后，会修改 b 对象的 name 的值，然后触发 KVO 回调，打印出 name 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-02-07 04:55:35.536953+0800 KVOImp[35950:2197387] name = 1</span><br><span class="line">2018-02-07 04:55:36.017987+0800 KVOImp[35950:2197387] name = 2</span><br><span class="line">2018-02-07 04:55:36.209775+0800 KVOImp[35950:2197387] name = 3</span><br></pre></td></tr></table></figure><p>在 <code>Bird *b = [[Bird alloc] init];</code> 一行设一个断点，重新运行程序，程序中断在这一行上。</p><p>让程序往下运行一步，然后在下方查看 b 对象的 isa 指针的值：</p><p><img src="http://or9vkv08s.bkt.clouddn.com/WX20180207-045854@2x.png"></p><p>这时 isa 的值是 Bird 这个类。</p><p>让程序再往下走一步，再次查看 b 对象的 isa 指针：</p><p><img src="http://or9vkv08s.bkt.clouddn.com/WX20180207-050111@2x.png"></p><p>会发现这时 b 对象的 isa 指针变为了 NSKVONotifying_Bird 这个类。</p><p>因此，可以大概知道，KVO 的实现原理为：</p><p><strong>在执行 <code>addObserver:selector:name:object:</code> 时，创建了一个被观察对象的子类，并重写了被观察属性的 setter 方法。</strong></p><p>下面来通过自己实现 KVO 来看一下具体的细节。</p><h3 id="自己动手实现-KVO"><a href="#自己动手实现-KVO" class="headerlink" title="自己动手实现 KVO"></a>自己动手实现 KVO</h3><p>下面我们来针对上面例子中 Bird 的 name 来自己实现 KVO。下面的实现中先写死仅对 setName: 方法实现 KVO，来提供一个最简单的实现流程。</p><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>创建一个 NSObject 的类别，文件为 NSObject+MyKVOImp.h 和 NSObject+MyKVOImp.m。</p><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>在 NSObject+MyKVOImp.h 中，添加两个方法声明：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)my_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="type">void</span> *)context;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)my_observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context;</span><br></pre></td></tr></table></figure><p>上面两个方法用于替代系统 KVO 提供的那两个不带前缀的方法。</p><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>在 NSObject+MyKVOImp.m 中添加 <code>my_addObserver...</code> 方法的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)my_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;NSKVONotifying_%@&quot;</span>, oldClassName];</span><br><span class="line">    </span><br><span class="line">    Class NewClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    class_addMethod(NewClass, <span class="keyword">@selector</span>(setName:), (IMP)setName, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(NewClass);</span><br><span class="line">    </span><br><span class="line">    object_setClass(<span class="keyword">self</span>, NewClass);</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedKey, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面代码的步骤进行说明：</p><h6 id="1-拿到当前类名，在前面加上-NSKVONotifying-前缀创建一个新的类名。"><a href="#1-拿到当前类名，在前面加上-NSKVONotifying-前缀创建一个新的类名。" class="headerlink" title="1. 拿到当前类名，在前面加上 NSKVONotifying_ 前缀创建一个新的类名。"></a>1. 拿到当前类名，在前面加上 NSKVONotifying_ 前缀创建一个新的类名。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;NSKVONotifying_%@&quot;</span>, oldClassName];</span><br></pre></td></tr></table></figure><h6 id="2-创建一个当前类的子类，并以新类名命名。"><a href="#2-创建一个当前类的子类，并以新类名命名。" class="headerlink" title="2. 创建一个当前类的子类，并以新类名命名。"></a>2. 创建一个当前类的子类，并以新类名命名。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class NewClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h6 id="3-为这个新类添加一个方法。"><a href="#3-为这个新类添加一个方法。" class="headerlink" title="3. 为这个新类添加一个方法。"></a>3. 为这个新类添加一个方法。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(NewClass, <span class="keyword">@selector</span>(setName:), (IMP)setName, <span class="string">&quot;v@:@&quot;</span>);</span><br></pre></td></tr></table></figure><p>同时提供了一个名为 setName 的 C 语言函数，相关代码会在后面给出。</p><p>先来看看 class_addMethod 的参数：</p><p>第一个参数指明了要添加方法的类。<br>第二个参数指定了添加的方法名为 setName 且带有一个参数。<br>第三个参数指定了方法实现对应的函数指针，即为 C 函数的函数名。<br>第四个参数指明了这个 C 函数的返回值和参数的类型。</p><p>这里的类型依次为：</p><p>返回值类型：v —— 代表 void<br>第一个参数类型：@ —— 代表对象<br>第二个参数类型：: —— 代表 SEL<br>第三个参数类型：@ —— 代表对象  </p><h6 id="4-把新创建的子类注册进运行时环境，使其可用。"><a href="#4-把新创建的子类注册进运行时环境，使其可用。" class="headerlink" title="4. 把新创建的子类注册进运行时环境，使其可用。"></a>4. 把新创建的子类注册进运行时环境，使其可用。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_registerClassPair(NewClass);</span><br></pre></td></tr></table></figure><h6 id="5-把调用-my-addObserver-方法的对象的-isa-指针设置为新创建的子类。"><a href="#5-把调用-my-addObserver-方法的对象的-isa-指针设置为新创建的子类。" class="headerlink" title="5. 把调用 my_addObserver 方法的对象的 isa 指针设置为新创建的子类。"></a>5. 把调用 my_addObserver 方法的对象的 isa 指针设置为新创建的子类。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_setClass(<span class="keyword">self</span>, NewClass);</span><br></pre></td></tr></table></figure><h6 id="6-把观察者关联到-self-上，使得可以在-setName-函数中取出。"><a href="#6-把观察者关联到-self-上，使得可以在-setName-函数中取出。" class="headerlink" title="6. 把观察者关联到 self 上，使得可以在 setName 函数中取出。"></a>6. 把观察者关联到 self 上，使得可以在 setName 函数中取出。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedKey, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br></pre></td></tr></table></figure><p>现在来看看 setName 函数的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> setName(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">    Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">&quot;_name&quot;</span>);</span><br><span class="line">    object_setIvar(<span class="keyword">self</span>, ivar, str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *observer = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([observer respondsToSelector:<span class="keyword">@selector</span>(my_observeValueForKeyPath:ofObject:change:context:)]) &#123;</span><br><span class="line">        [observer my_observeValueForKeyPath:<span class="string">@&quot;name&quot;</span> ofObject:<span class="keyword">self</span> change:@&#123;<span class="built_in">NSKeyValueChangeNewKey</span>: str&#125; context:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道每个 Objective-C 方法都含有两个隐式参数 self 和 _cmd，他们对应 C 函数中的第一个和第二个参数。因此 setName 的函数的第一个和第二个参数必须是 id self 和 SEL _cmd。第三个参数才是作为生成的 Objective-C 方法 <code>setName:</code> 的第一个参数。</p><p>上面说到 setName 的返回值类型和参数类型依次为 “v@:@”，可以根据上面的说明检查这里的 setName 函数 的实现是不是如此。</p><p>在 setName 的实现中：</p><h6 id="1-修改实例变量的值。"><a href="#1-修改实例变量的值。" class="headerlink" title="1. 修改实例变量的值。"></a>1. 修改实例变量的值。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ivar ivar = class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">&quot;_name&quot;</span>);</span><br><span class="line">object_setIvar(<span class="keyword">self</span>, ivar, str);</span><br></pre></td></tr></table></figure><h6 id="2-获取到关联的-Observer-对象。"><a href="#2-获取到关联的-Observer-对象。" class="headerlink" title="2. 获取到关联的 Observer 对象。"></a>2. 获取到关联的 Observer 对象。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *observer = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kAssociatedKey);</span><br></pre></td></tr></table></figure><h6 id="3-调用-my-observeValueForKeyPath-方法。"><a href="#3-调用-my-observeValueForKeyPath-方法。" class="headerlink" title="3. 调用 my_observeValueForKeyPath... 方法。"></a>3. 调用 <code>my_observeValueForKeyPath...</code> 方法。</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([observer respondsToSelector:<span class="keyword">@selector</span>(my_observeValueForKeyPath:ofObject:change:context:)]) &#123;</span><br><span class="line">    [observer my_observeValueForKeyPath:<span class="string">@&quot;name&quot;</span> ofObject:<span class="keyword">self</span> change:@&#123;<span class="built_in">NSKeyValueChangeNewKey</span>: str&#125; context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个简单的 KVO 就实现好了，可以在 ViewController 中调用我们自己实现的方法试试效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;Bird.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;NSObject+MyKVOImp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Bird *bird;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.bird = [[Bird alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.bird my_addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)my_observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;name = %@&quot;</span>, <span class="keyword">self</span>.bird.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> i = <span class="number">0</span>;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">self</span>.bird.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, @(i)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>运行程序，可以看到每次点击屏幕，修改 name 的值后，会触发 my_observeValueForKeyPath 的调用，把 name 的值打印出来：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">56.200072</span>+<span class="number">0800</span> KVOImp[<span class="number">37915</span>:<span class="number">2306333</span>] name = <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">59.099350</span>+<span class="number">0800</span> KVOImp[<span class="number">37915</span>:<span class="number">2306333</span>] name = <span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-02</span><span class="number">-07</span> <span class="number">10</span>:<span class="number">49</span>:<span class="number">46.448505</span>+<span class="number">0800</span> KVOImp[<span class="number">37915</span>:<span class="number">2306333</span>] name = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上我们介绍了 KVO 的实现原理并自己实现了一个简单的 KVO，实际上 KVO 的实现还是很复杂的，要考虑到很多地方，复杂的实现网上有相关代码，或者看 KVO 源码了解一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;KVO-的实现原理&quot;&gt;&lt;a href=&quot;#KVO-的实现原理&quot; class=&quot;headerlink&quot; title=&quot;KVO 的实现原理&quot;&gt;&lt;/a&gt;KVO 的实现原理&lt;/h3&gt;&lt;p&gt;在 Objective-C 中，用 KVO 可以很方便的观察某个属性的值的变化，一有</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Method Swizzling 实现不修改任何代码替换掉某个方法的实现</title>
    <link href="https://liuduoios.github.io/method-swizzling-replace-imp/"/>
    <id>https://liuduoios.github.io/method-swizzling-replace-imp/</id>
    <published>2018-02-06T15:44:06.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Method-Swizzling-和应用举例"><a href="#Method-Swizzling-和应用举例" class="headerlink" title="Method Swizzling 和应用举例"></a>Method Swizzling 和应用举例</h3><p>直接从例子开始讲起。</p><p>例如 NSURL 的 URLWithString: 方法，通过它来创建 NSURL 时，如果输入的参数不合法，会导致创建出来的对象为 nil，从而导致后面的程序异常。</p><p>当然，我们需要保证输入的参数一定是不合法的。但是有的时候我们希望无论输入任何参数，都能保证正常的创建出 NSURL 对象，而不是 nil。</p><p>这个时候可以另写一个方法，在里面做好判断，然后所有之前调用 URLWithString: 的地方都改为去调用这个方法。</p><p>当然这样也可以，但是还有一种方法，它不需要改动任何现有的代码就能实现意图，这就是 Objective-C 的黑魔法 —— Method Swizzling。</p><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><h4 id="1-创建-NSURL-的类别"><a href="#1-创建-NSURL-的类别" class="headerlink" title="1. 创建 NSURL 的类别"></a>1. 创建 NSURL 的类别</h4><p>创建一个 NSURL 的类别，文件为叫做 NSURL+Safe.h 和 NSURL+Safe.m。</p><h4 id="2-编写要替换成的方法"><a href="#2-编写要替换成的方法" class="headerlink" title="2. 编写要替换成的方法"></a>2. 编写要替换成的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)safe_URLWithString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:string];</span><br><span class="line">    <span class="keyword">if</span> (!URL) &#123;</span><br><span class="line">        URL = [[<span class="built_in">NSURL</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> URL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NSURL 类别中添加上面方法，主要实现为如果通过 URLWithString: 创建得到的对象为 nil，那么则自己直接 [[NSURL alloc] init] 创建一个空的 NSURL 对象。</p><h4 id="3-编写-load-方法"><a href="#3-编写-load-方法" class="headerlink" title="3. 编写 load 方法"></a>3. 编写 load 方法</h4><p>现在介绍一下 load 会在什么时机被调用：当类被加载进内存时（实际上为 objc_class 对象）被调用，在 App 启动时会自动加载需要的所有类进内存，所有 load 的调用时间是非常早的，在 main 函数调用之前。</p><p>另外还有两个规则：</p><ul><li>当父类和子类都实现 load 函数时，父类的 load 函数会被先执行</li><li>类别中的 load 不会替换原始类中的 load 方法，原始类和类别中的 load 方法都会被执行，原始类的 load 方法先被执行后，再执行类别中的 load 方法。如果有多个类别都实现了 load 方法，这些类别中的 load 的方法的执行顺序是不确定的。</li></ul><p>下面来编写 load 方法：</p><p>由于用到了 Runtime API，需要在文件头部包含 <code>#import &lt;objc/runtime.h&gt;</code>。</p><p>load 方法中主要是对 <code>method_exchangeImplementations</code> 方法的调用，它接受两个类型为 Method 的参数。它的作用是交换两个方法的实现的指针地址（IMP）。</p><p>可以通过 <code>class_getClassMethod</code> 和 <code>class_getInstanceMethod</code> 来获取类方法或者实例方法的 Method 类型对象。</p><p>load 方法的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    Method systemMethod = class_getClassMethod([<span class="built_in">NSURL</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(URLWithString:));</span><br><span class="line">    Method customMethod = class_getClassMethod([<span class="built_in">NSURL</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(safe_URLWithString:));</span><br><span class="line">    method_exchangeImplementations(systemMethod, customMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-修改自定义方法中的调用"><a href="#4-修改自定义方法中的调用" class="headerlink" title="4. 修改自定义方法中的调用"></a>4. 修改自定义方法中的调用</h4><p>在上面的 safe_URLWithString 方法中，调用了 NSURL 的 URLWithString 方法。在添加完 load 方法后，由于 App 启动后会交换 URLWithString 和 safe_URLWithString 的实现，因此调用 URLWithString 实际上变成了调用 safe_URLWithString 自己，就会造成死循环。所以要改为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)safe_URLWithString:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> safe_URLWithString:string];</span><br><span class="line">    <span class="keyword">if</span> (!URL) &#123;</span><br><span class="line">        URL = [[<span class="built_in">NSURL</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> URL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看上去像是循环调用了，实际上是没有问题，不过不熟悉实现机制的人看到可能会比较懵逼，可以加上注释进行说明。</p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h4><p>现在，可以编写一些测试代码看看是否生效。比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;aweg:\eahgiowe&quot;</span>];</span><br></pre></td></tr></table></figure><p>会发现本来返回 nil 的 URLWithString 方法现在能返回一个 NSURL 对象了。</p><h4 id="5-在任意项目中使用"><a href="#5-在任意项目中使用" class="headerlink" title="5. 在任意项目中使用"></a>5. 在任意项目中使用</h4><p>目前是指编写了两个文件 NSURL+Safe.h 和 NSURL+Safe.m 并添加到项目中，项目中其它部分完全没有修改。</p><p>如果想把这个功能应用到一个新的项目中，只要把这两个文件拷过去，添加到项目中即可，别的什么都不用做，非常方便。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当任何时候想要替换项目中某个方法的实现时，都可以采用这个方法，只要编写一个类别，在里面用 Method Swizzling 交换方法实现，然后把类别添加进项目中即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Method-Swizzling-和应用举例&quot;&gt;&lt;a href=&quot;#Method-Swizzling-和应用举例&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzling 和应用举例&quot;&gt;&lt;/a&gt;Method Swizzling 和应用</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime（三）：编译器</title>
    <link href="https://liuduoios.github.io/objective-c-runtime-3-compiler/"/>
    <id>https://liuduoios.github.io/objective-c-runtime-3-compiler/</id>
    <published>2018-02-05T02:34:25.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C Runtime 包含两大组件——<strong>编译器</strong>和<strong>Runtime API</strong>，本篇探讨一下编译器组件扮演的角色和它的工作原理。</p><p>苹果官方文档中介绍了三种和 Runtime 交互的方式：</p><ol><li>Objective-C 源代码本身。</li><li>调用 NSObject 中的方法。</li><li>调用包含在 &lt;objc&#x2F;runtime.h&gt;、&lt;objc&#x2F;message.h&gt; 中的函数。</li></ol><p>其中第一条“Objective-C 源代码本身”的含义就是，所有 Objective-C 源代码都是会被转换成 Runtime 代码运行，这个过程中开发者不用做任何事情，只要去编写 Objective-C 代码，编译，运行，这个过程中就自动在和 Runtime 进行交互了。</p><p>这也就是 Objective-C 的第一个组建——编译器做的事情，即把 Objective-C 代码转换为 Runtime 代码。</p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>Runtime 编译器的作用就是把任何 Objective-C 的代码编译为 Runtime 的 C 代码。</p><p>这个过程中，会把 Objective-C 的数据结构编译为 Runtime 的 C 的数据结构。把 Objective-C 的消息传递编译为 Runtime 的 C 函数调用。</p><p>下面来看看 Objective-C 中的各个元素在 Runtime 中对应的是什么。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>Runtime 的核心数据结构就是对象，其实在 Objective-C 中，一切都是对象，对象在 Runtime 中是一个名为 objc_object 的结构体。Objective-C 中的任何对象都是用 objc_object 来表示的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">isa_t</span> isa;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_object 中最关键的部分是一个 isa_t 类型的 isa 变量。isa_t 类型使用了 Tagged Pointer 技术来减小内存空间的占用。isa 指针主要保存了对象关联的类的信息。</p><p>id 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure><p>id 是一个指向 objc_object 类型的指针，因此 id 可以代表任何对象。</p><h4 id="不透明类型"><a href="#不透明类型" class="headerlink" title="不透明类型"></a>不透明类型</h4><p>不透明类型是一种 C 语言结构体，它的声明中只暴露了部分信息，隐藏了它的具体实现细节。</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的 isa 指针指向它的元类。</p><p>Class 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br></pre></td></tr></table></figure><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>元类中保存了这个类的类方法的地址。元类的 isa 指针指向元类对应的类的父类的元类。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法在 Runtime 中用 Method 类型来表示，从 Runtime 的源码可以看到，Method 类型是一个指向 method_t 结构体类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> *offset;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mangledName;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="type">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *optionalInstanceMethods;</span><br><span class="line">    <span class="type">method_list_t</span> *optionalClassMethods;</span><br><span class="line">    <span class="type">property_list_t</span> *instanceProperties;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Objective-C-方法和隐含参数"><a href="#Objective-C-方法和隐含参数" class="headerlink" title="Objective-C 方法和隐含参数"></a>Objective-C 方法和隐含参数</h3><p>对于每一个 Objective-C 的方法，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)printCount:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器都会将其编译成一个 C 函数，上面的方法会被编译成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(id self, SEL _cmd, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 C 函数的第一个和第二个参数就是隐含参数，在 Objective-C 的方法体中，也是可以直接使用的。编译为 C 函数后，需要在函数声明中明确的声明。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>对于消息传递的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver message];</span><br></pre></td></tr></table></figure><p>编译器会把它编译成对 C 函数 objc_msgSend 的调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, @selector(message));</span><br></pre></td></tr></table></figure><h3 id="代码编译实例"><a href="#代码编译实例" class="headerlink" title="代码编译实例"></a>代码编译实例</h3><p>因为 Objective-C 的源代码都会被编译成 Runtime 代码来运行，我们一样可以通过直接编写 Runtime 代码的方式来编写程序。</p><p>例如我们有个类叫 ClassA：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> count;</span><br><span class="line">- (<span class="type">void</span>)printCount;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line">- (<span class="type">void</span>)printCount &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;count = %@&quot;</span>, @(<span class="keyword">self</span>.count));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后来看看下面代码转成 Runtime 怎么写：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassA *a = [[ClassA alloc] init];</span><br><span class="line">a.count = <span class="number">100</span>;</span><br><span class="line">[a printCount];</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到 ClassA 的 Class 对象</span></span><br><span class="line">Class ClassA = objc_getClass(<span class="string">&quot;ClassA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送 alloc 和 init 消息来创建和初始化实例对象</span></span><br><span class="line"><span class="type">id</span> a = objc_msgSend(ClassA, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">a = objc_msgSend(a, <span class="keyword">@selector</span>(init));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到属性 count 背后的实例变量</span></span><br><span class="line">Ivar countIvar = class_getInstanceVariable(ClassA, <span class="string">&quot;_count&quot;</span>);</span><br><span class="line">assert(countIvar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过实例对象首地址 + 实例变量的地址偏移量得到实例变量的指针地址，然后通过 * 取指针值操作符修改指针指向的地址的值。</span></span><br><span class="line"><span class="built_in">CFTypeRef</span> aRef = <span class="built_in">CFBridgingRetain</span>(a);</span><br><span class="line"><span class="type">int</span> *countIvarPtr = (<span class="type">int</span> *)((uint8_t *)aRef + ivar_getOffset(countIvar));</span><br><span class="line">*countIvarPtr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">CFBridgingRelease</span>(aRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 a 对象发送 printCount 消息，打印 count 属性的值</span></span><br><span class="line">objc_msgSend(a, <span class="keyword">@selector</span>(printCount));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = 100</span><br></pre></td></tr></table></figure><h3 id="使用-clang-来查看编译后的代码"><a href="#使用-clang-来查看编译后的代码" class="headerlink" title="使用 clang 来查看编译后的代码"></a>使用 clang 来查看编译后的代码</h3><p>可以使用 clang 命令来生成编译后的 Runtime 代码。</p><p>假设上面的例子的代码都写在 main.m 中，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure><p>执行完毕后会在同一目录下生成一个 main.cpp 文件，打开它，搜索 int main() 可以看到：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        ClassA *a = ((ClassA *(*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)((ClassA *(*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)objc_getClass(<span class="string">&quot;ClassA&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>));</span><br><span class="line">        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="built_in">NSInteger</span>))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)a, sel_registerName(<span class="string">&quot;setCount:&quot;</span>), (<span class="built_in">NSInteger</span>)<span class="number">100</span>);</span><br><span class="line">        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *)objc_msgSend)((<span class="type">id</span>)a, sel_registerName(<span class="string">&quot;printCount&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面我们写的代码有点不同，但是可以看到生成的代码中也是大量使用了 objc_msgSend 的调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Objective-C Runtime 包含两大组件——&lt;strong&gt;编译器&lt;/strong&gt;和&lt;strong&gt;Runtime API&lt;/strong&gt;，本篇探讨一下编译器组件扮演的角色和它的工作原理。&lt;/p&gt;
&lt;p&gt;苹果官方文档中介绍了三种和 Runtime 交互的方式</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime（二）：动态类型，动态绑定，动态方法决议，内省</title>
    <link href="https://liuduoios.github.io/objective-c-runtime-2-dynamic-typing-and-dynamic-binding/"/>
    <id>https://liuduoios.github.io/objective-c-runtime-2-dynamic-typing-and-dynamic-binding/</id>
    <published>2018-02-01T15:13:55.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 Objective-C Runtime 的四个重要的概念——<strong>动态类型，动态绑定，动态方法决议，内省</strong>，为后面的研究打下基础。</p><h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><p>动态类型（Dynamic typing）是指对象的具体类型在<strong>运行时</strong>才能确定。</p><p>在 Objective-C 中，对象的类型可以定义成静态的，也可以定义成动态的。</p><p>下面代码中的 number 的类型被定义为 NSNumber *，它是静态类型。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number;</span><br></pre></td></tr></table></figure><p>动态类型一般用 <code>id</code> 关键字来定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> object;</span><br></pre></td></tr></table></figure><p>这个 object 可以是任何类型。</p><p>然而静态类型的作用是告诉编译器做类型检查，保证在代码中不会出现类型不匹配的赋值等操作。实际上定义为静态类型的对象也可能是动态类型。在实际开发中还是会出现类似于定义为 NSNumber 的类型实际上保存的值是一个 NSString 的现象，需要小心谨慎。</p><p>动态类型的存在可以让代码更加灵活。</p><p>比如一个方法的某个参数支持传入多种类型，有了 id 这个类型，这个方法就只要声明一次，而不用对于每种参数类型都声明一个方法，从而减少方法的数量。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)computeValue:(<span class="type">id</span>)parameter;</span><br></pre></td></tr></table></figure><p>Objective-C 也支持定义为符合某个协议的任意类型：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)computeValue:(<span class="type">id</span>&lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)parameter;</span><br></pre></td></tr></table></figure><p>或者是类型为某个类或其子类，同时符合某个协议的任意类型：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)computeValue:(<span class="built_in">NSNumber</span>&lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt; *)parameter;</span><br></pre></td></tr></table></figure><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>动态绑定（Dynamic binding）是指把消息映射到方法实现的这一过程是在运行时，而不是在编译时完成的。</p><p>例如下面代码中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">id</span> computer = [[Computer alloc] initWithBrand:<span class="string">@&quot;Dell&quot;</span>];</span><br><span class="line">[computer logInfo];</span><br></pre></td></tr></table></figure><p>可能有多个类都实现了 logInfo 方法，被声明为 id 类型的 computer 对象也可能是任意具体类型。当 logInfo 消息发送给 computer 对象时，Runtime 会先去决定 computer 的实际类型，然后用 logInfo 的 Selector 在 computer 的实际类型中去寻找对应的方法实现，如果 computer 的类型中找不到，还会继续去它的父类中找。</p><p>Objective-C 对于消息传递（方法调用）的处理可以简化为下面三个步骤：</p><ol><li>决定消息接受者的类型（动态类型）</li><li>决定消息对应的方法实现（动态绑定）</li><li>调用方法</li></ol><h3 id="动态方法决议"><a href="#动态方法决议" class="headerlink" title="动态方法决议"></a>动态方法决议</h3><p>动态方法决议（Dynamic Method Resolution）是一种能为方法动态的提供方法实现的能力。</p><p>Objective-C 的 <code>@dynamic</code> 关键字就属于动态方法决议，这个关键字告诉编译器这个属性的 setter 和 getter 方法是在运行时动态提供的。例如 Core Data 框架中就大量使用了 @dynamic 来实现更高效的数据访问。</p><p>NSObject 包含两个类方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ resolveInstanceMethod:</span><br></pre></td></tr></table></figure><p><code>resolveInstanceMethod</code> 为给定的 Selector 提供一个实例方法的实现。这个方法会在每次实例对象收到消息时调用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ resolveClassMethod</span><br></pre></td></tr></table></figure><p><code>resolveClassMethod</code> 为给定的 Selector 给提供一个类方法的实现。这个方法会在每次类收到消息时调用。</p><p>复写这两个方法即可在运行时为实例方法或类方法动态的提供实现。</p><p>举个例子：</p><p>有个空的 Bird 类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bird</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bird.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>创建一个 Bird 的实例，给它发送一个 fly 消息</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line">Bird *bird = [[Bird alloc] init];</span><br><span class="line">[bird performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;fly&quot;</span>)];</span><br></pre></td></tr></table></figure><p>由于 fly 消息没有被声明，只能用 <code>performSelector:NSSelectorFromString ...</code> 这种方式在运行时发送消息。</p><p>当然这时程序是会崩溃的，因为 Bird 类并没有 fly 方法，因此 bird 对象无法处理这个消息。</p><p>现在在 Bird.m 的头部添加名为 fly 的 C 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.m</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fly</span><span class="params">(id self, SEL _cmd)</span> &#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Bird are flying...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为 Bird 添加 resolveInstanceMethod: 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bird.m</span></span><br><span class="line">+ (<span class="type">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *method = <span class="built_in">NSStringFromSelector</span>(sel); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> ([method isEqualToString:<span class="string">@&quot;fly&quot;</span>]) &#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)fly, <span class="string">&quot;v@:&quot;</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码执行步骤如下：</p><ol><li>取得表示指定 Selector 的字符串。</li><li>如果字符串为 “fly”，为 Bird 类添加 fly 方法，方法的实现为上面定义的 fly 函数。</li><li>返回 YES 表示已经自己正确的处理好了这个方法实现的提供。</li></ol><p>运行程序，当 bird 对象收到 fly 消息时，会触发 resolveInstanceMethod: 的调用，这里会为 Bird 类动态地添加 fly 方法，然后 bird 对象会继续处理 fly 消息，这时就能正确的调用了，因为找到了 fly 方法的实现，会在控制台打印出 “Bird are flying…”。</p><blockquote><p>注：如果不明白 fly 函数中 id self, SEL _cmd 的作用，class_addMethod 方法的使用，”v@:” 是什么等等，后面的文章会有对这些方面的介绍。</p></blockquote><h3 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h3><p>NSObject API 中提供了对象内省（Introspection）的功能。内省是一种能在运行时检查对象自身信息的能力。</p><p>由于 Objective-C 的大量行为都是在运行时完成的，内省能力便至关重要。</p><p>NSObject 对象提供的内省方法主要有：</p><p><code>isKindOfClass:</code><br>检查对象是否是给定的 Class 的实例或给定 Class 的子类的实例。</p><p><code>respondsToSelector:</code><br>检查对象是否能响应某个 Selector。</p><p><code>conformsToProtocol:</code><br>检查对象是否符合某个协议。</p><p><code>methodSignatureForSelector:</code><br>获取某个 Selector 得方法签名。</p><p>如果一个方法用动态类型 id 作为参数，例如前面提到的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)computeValue:(<span class="type">id</span>)parameter;</span><br></pre></td></tr></table></figure><p>通常要对这个参数进行内省检查来决定进一步操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍了 Objective-C Runtime 的四个重要的概念——&lt;strong&gt;动态类型，动态绑定，动态方法决议，内省&lt;/strong&gt;，为后面的研究打下基础。&lt;/p&gt;
&lt;h3 id=&quot;动态类型&quot;&gt;&lt;a href=&quot;#动态类型&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime（一）：Selector 和方法签名</title>
    <link href="https://liuduoios.github.io/objective-c-runtime-1-selector-and-method-signature/"/>
    <id>https://liuduoios.github.io/objective-c-runtime-1-selector-and-method-signature/</id>
    <published>2018-01-31T12:32:39.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>在日常开发中，会经常接触到 Selector，例如常用到的 Target-Action 模式中，Action 就是一个 Selector 类型。所以 Selector 大家想必都很熟悉。</p><p>Selector 是一个<strong>字符串</strong>，用于指代某个类方法或实例方法。</p><p>例如一个类有下面两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)addNumber1:(<span class="built_in">NSInteger</span>)number1 andNumber2:(<span class="built_in">NSInteger</span>)number2;</span><br></pre></td></tr></table></figure><p>他们的选择器分别为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;description&quot;</span></span><br><span class="line"><span class="string">&quot;addNumber1:andNumber2:&quot;</span></span><br></pre></td></tr></table></figure><p>对于有两个或两个以上参数的方法，如果某个参数的名称为空，那么方法的 Selector 的对应部分也为空。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)add:(<span class="built_in">NSInteger</span>)number1 :(<span class="built_in">NSInteger</span>)number2;</span><br></pre></td></tr></table></figure><p>上面方法的 Selector 为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;add::&quot;</span></span><br></pre></td></tr></table></figure><p>Selector 可以被发送给某个对象或类来进行方法调用，这时被发送的 Selector 需要带上输入参数。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[calculator addNumber1:<span class="number">40</span> andNumber:<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>这里就是把一个 Selector <code>addNumber1:andNumber2</code> 带上了参数发送给了 calulator 对象。</p><h3 id="SEL-类型"><a href="#SEL-类型" class="headerlink" title="SEL 类型"></a>SEL 类型</h3><p>SEL，即 Selector 类型，是 Objective-C 的一个特殊的类型，它是一个<strong>唯一的标识符</strong>，来代表某个 Selector。相同的 Selector 的 SEL 标识符一定也是相同的。</p><p>创建 SEL 类型的变量有两种方式：</p><p><strong>编译时创建：</strong><br>用 @selector 关键字来 创建，这时代码补全功能能在当前位置寻找已经声明过的 Selector，同时编译器也会检查 Selector 的合法性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="keyword">@selector</span>(addNumber1:andNumber2:);</span><br></pre></td></tr></table></figure><p><strong>运行时创建：</strong><br>用 NSSelectorFromString 创建，参数用一个字符串类型来代表传入的 Selector，运行时可以根据需要来传入不同的 Selector：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEL selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;addNumber1:andNumber2:&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><p>方法签名定义了一个方法的参数和返回值的类型。</p><p>方法签名在日常开发中使用的频度不高，但是它必须得存在，它存在的意义是什么呢？</p><p>这就要提到 Objective-C 进行消息传递的机制了，Objective-C 中给对象发送一个消息，例如 <code>[object description]</code>，会被编译成一个 C 函数的调用（objc_msgSend），这个 C 函数的生成需要知道两个信息，一个是函数名及其参数列表，一个是参数的类型和返回值的类型。</p><p>函数名和参数列表可以从 Selector 中获得，参数和返回值类型则是从方法签名中获得。因此为了确定一个方法，Selector 和方法签名缺一不可。</p><p>编译器在编译时会检查每个方法的声明，从中解析出 Selector 和方法签名。</p><h3 id="签名不匹配"><a href="#签名不匹配" class="headerlink" title="签名不匹配"></a>签名不匹配</h3><p>由于 Objective-C 在方法调用（消息传递）时，具有动态类型（Dynamic typing）的特性，消息的接收者的类型在运行时才能确定。对于可能为任何类型的接收者，例如接收者为 id 类型，因为编译器只能基于方法声明上取得方法签名，这时编译器取得的方法签名只是一个推测值，这就有可能会发生签名不匹配。当发生签名不匹配时，这类情况会导致各种运行时错误，如栈溢出、无效的输入输出参数或无效的返回值等。</p><p>例如有下面三个类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Calculator1</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">int</span>)addNumber1:(<span class="built_in">NSInteger</span>)number1 andNumber2:(<span class="built_in">NSInteger</span>)number2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Calculator2</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">float</span>)addNumber1:(<span class="type">float</span>)number1 andNumber2:(<span class="type">float</span>)number2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Calculator3</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)addNumber1:(<span class="built_in">NSInteger</span>)number1 andNumber2:(<span class="built_in">NSInteger</span>)number2;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对于有可能是这三种类型中的任何一种的接收者，编译器推测的方法类型可能是错误的。如下面的消息传递：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[receiver addNumber1:<span class="number">25</span> andNumber2:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>编译器在生成 C 函数时，使用的 Selector 为 <code>addNumber1:andNumber2</code>，方法签名为 <code>(NSInteger, NSInteger) -&gt; int</code>。</p><p>然后实际消息发送中，发现 receiver 是 Calculator2 类型，就会发生方法不匹配，从而发生运行时错误。</p><h3 id="怎样避免发生签名不匹配"><a href="#怎样避免发生签名不匹配" class="headerlink" title="怎样避免发生签名不匹配"></a>怎样避免发生签名不匹配</h3><p>避免这类问题发生的办法就是对于方法签名相同的方法，尽量采用不同的名字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Selector&quot;&gt;&lt;a href=&quot;#Selector&quot; class=&quot;headerlink&quot; title=&quot;Selector&quot;&gt;&lt;/a&gt;Selector&lt;/h3&gt;&lt;p&gt;在日常开发中，会经常接触到 Selector，例如常用到的 Target-Action 模式</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>用 Docker 搭建 Hexo 博客</title>
    <link href="https://liuduoios.github.io/docker-hexo/"/>
    <id>https://liuduoios.github.io/docker-hexo/</id>
    <published>2018-01-29T06:53:31.000Z</published>
    <updated>2023-06-05T05:33:26.597Z</updated>
    
    <content type="html"><![CDATA[<p>这几年不会 Docker 都不好意思出门见人，传统的方式来搭建 Hexo 博客已经不 cool 了，下面来介绍下怎样用 Docker 来搭建 Hexo 博客。</p><h4 id="1-准备-Hexo-博客源码"><a href="#1-准备-Hexo-博客源码" class="headerlink" title="1. 准备 Hexo 博客源码"></a>1. 准备 Hexo 博客源码</h4><p>创建一个目录，把 Hexo 博客源码都放进去，或者直接 cd 到现有的 Hexo 源码目录。</p><p>在目录中设置好主题，要发布的文章等，用 <code>hexo server</code> 看效果，一切准备完毕。</p><h4 id="2-创建-Dockerfile"><a href="#2-创建-Dockerfile" class="headerlink" title="2. 创建 Dockerfile"></a>2. 创建 Dockerfile</h4><p>在 Hexo 源码根目录下创建 Dockerfile 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> author=liuduo email=liuduome@gmail.com site=http://liuduo.me</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y epel-release &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">yum install -y nodejs &amp;&amp; npm install hexo-cli -g </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;hexo&quot;</span>, <span class="string">&quot;server&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>下面来分步说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br></pre></td></tr></table></figure><p>FROM 用来指定父镜像，这里用 centos 作为父镜像，指定 centos 的版本为 7。其后的任务都会在这个父镜像内进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL author=liuduo email=liuduome@gmail.com site=http://liuduo.me</span><br></pre></td></tr></table></figure><p>LABEL 用来指定一些信息，例如作者，邮箱，网址等等，这个也可以不写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /app</span><br></pre></td></tr></table></figure><p>指定工作目录为 &#x2F;app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD . /app</span><br></pre></td></tr></table></figure><p>把当前目录中的文件（Hexo 源码）都拷贝到容器的 &#x2F;app 目录中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN yum install -y epel-release &amp;&amp; \</span><br><span class="line">yum install -y nodejs &amp;&amp; npm install hexo-cli -g </span><br></pre></td></tr></table></figure><p>在前面指定的工作目录（&#x2F;app）下执行一些命令，这里做了添加 EPEL 源，安装 nodejs，安装 hexo 三件事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 4000</span><br></pre></td></tr></table></figure><p>指定容器对外提供服务的端口为 4000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;hexo&quot;, &quot;server&quot;]</span><br></pre></td></tr></table></figure><p>服务启动的入口点，这里为执行 <code>hexo server</code>。</p><h4 id="3-生成镜像"><a href="#3-生成镜像" class="headerlink" title="3. 生成镜像"></a>3. 生成镜像</h4><p>使用 docker build 命令基于 Dockerfile 来构建镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-hexo-blog .</span><br></pre></td></tr></table></figure><p>docker build 命令的使用格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH</span><br></pre></td></tr></table></figure><p>上面先通过 -t my-hexo-blog 参数指定了镜像名为 my-hexo-blog。</p><p>随后指定了要基于哪个目录构建，用 <code>.</code> 来代表当前目录。</p><p>镜像生成完成后，可以执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>来查看当前镜像列表中是否已经存在 my-hexo-blog 镜像。</p><h4 id="4-通过镜像启动并运行一个容器"><a href="#4-通过镜像启动并运行一个容器" class="headerlink" title="4. 通过镜像启动并运行一个容器"></a>4. 通过镜像启动并运行一个容器</h4><p>通过 docker container run 来运行容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p 4000:4000 [容器ID] </span><br></pre></td></tr></table></figure><p>-d 参数代表放在后台运行，这样当前命令行中不会打印服务的运行日志。</p><p>-p 指定了本机端口和容器端口的映射，这里本机端口和容器端口都使用 4000，因此是 <code>-p 4000:4000</code>。</p><p>命令执行完后，打开浏览器输入 <code>http://localhost:4000</code> 就能看到自己的博客了。</p><h4 id="5-把镜像保存到文件"><a href="#5-把镜像保存到文件" class="headerlink" title="5. 把镜像保存到文件"></a>5. 把镜像保存到文件</h4><p>用 docker save 来保存镜像到文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my-hexo-blog &gt; ./my-hexo-blog.tar</span><br></pre></td></tr></table></figure><p>上面命令中镜像名和文件名都可以换成自己的。</p><p>保存成文件后，可以把这个文件随便拷贝到任何一台部署了 docker 服务的计算机上。</p><h4 id="6-加载镜像文件"><a href="#6-加载镜像文件" class="headerlink" title="6. 加载镜像文件"></a>6. 加载镜像文件</h4><p>将镜像文件拷贝到一台部署了 docker 服务的计算机上后，可以用 docker load 来加载镜像文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; ./my-hexo-blog.tar</span><br></pre></td></tr></table></figure><p>然后查看下本机镜像列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>会发现新的计算机上也有这个镜像了，然后可以用上面提到的 <code>docker run</code> 来用这个镜像运行一个容器了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几年不会 Docker 都不好意思出门见人，传统的方式来搭建 Hexo 博客已经不 cool 了，下面来介绍下怎样用 Docker 来搭建 Hexo 博客。&lt;/p&gt;
&lt;h4 id=&quot;1-准备-Hexo-博客源码&quot;&gt;&lt;a href=&quot;#1-准备-Hexo-博客源码&quot; cla</summary>
      
    
    
    
    <category term="后端" scheme="https://liuduoios.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Docker" scheme="https://liuduoios.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 奇葩写法合集</title>
    <link href="https://liuduoios.github.io/weird_objectivec/"/>
    <id>https://liuduoios.github.io/weird_objectivec/</id>
    <published>2017-12-05T07:49:37.000Z</published>
    <updated>2023-06-05T05:33:26.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内联复合表达式"><a href="#内联复合表达式" class="headerlink" title="内联复合表达式"></a>内联复合表达式</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view = (&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *v = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    v.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    v;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在创建对象时，使用内联符合表达式是一个很好的技巧。例如在一个视图中创建并初始化很多子视图时，内联符合表达式可以使代码分块，结构上更清晰。</p><p>下面这种写法也是合法的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&#123;</span><br><span class="line">    <span class="built_in">UIView</span> *v = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">    v;</span><br><span class="line">&#125;).backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure><h1 id="最短函数名"><a href="#最短函数名" class="headerlink" title="最短函数名"></a>最短函数名</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-_ &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> _];</span><br></pre></td></tr></table></figure><h1 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">CGRect</span> rect2 = &#123;.origin.x=<span class="number">5</span>, .size=&#123;<span class="number">10</span>, <span class="number">10</span>&#125;&#125;; <span class="comment">// &#123;5, 0, 10, 10&#125;</span></span><br><span class="line"><span class="built_in">CGRect</span> rect3 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// &#123;1, 2, 0, 0&#125;</span></span><br></pre></td></tr></table></figure><h1 id="C-风格函数定义"><a href="#C-风格函数定义" class="headerlink" title="C 风格函数定义"></a>C 风格函数定义</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum(a, b)</span><br><span class="line"><span class="type">int</span> a; <span class="type">int</span> b;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组下标初始化"><a href="#数组下标初始化" class="headerlink" title="数组下标初始化"></a>数组下标初始化</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">int</span> numbers[] = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">66</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">77</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">88</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">99</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// &#123;0, 66, 77, 88, 0, 99&#125;</span></span><br></pre></td></tr></table></figure><h1 id="字符行多行初始化"><a href="#字符行多行初始化" class="headerlink" title="字符行多行初始化"></a>字符行多行初始化</h1><p>也是很常用的技巧，可以让一个很长的字符串字面量通过换行达到提高可读性的效果。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@&quot;apple&quot;</span></span><br><span class="line">                   <span class="string">@&quot;banana&quot;</span></span><br><span class="line">                   <span class="string">@&quot;orange&quot;</span></span><br><span class="line">                   <span class="string">@&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>效果等价于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@&quot;applebananabughello&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="的非主流用法"><a href="#的非主流用法" class="headerlink" title="?: 的非主流用法"></a>?: 的非主流用法</h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!block ?: block();</span><br></pre></td></tr></table></figure><p>效果等价于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block) &#123;</span><br><span class="line">    block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.zhihu.com/question/27655570">https://www.zhihu.com/question/27655570</a></li><li><a href="http://blog.sunnyxx.com/2014/08/02/objc-weird-code/">http://blog.sunnyxx.com/2014/08/02/objc-weird-code/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内联复合表达式&quot;&gt;&lt;a href=&quot;#内联复合表达式&quot; class=&quot;headerlink&quot; title=&quot;内联复合表达式&quot;&gt;&lt;/a&gt;内联复合表达式&lt;/h1&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="Objective-C" scheme="https://liuduoios.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
  <entry>
    <title>最全的 Swift 4 新特性解析</title>
    <link href="https://liuduoios.github.io/Whats_new_in_swift_4_completely/"/>
    <id>https://liuduoios.github.io/Whats_new_in_swift_4_completely/</id>
    <published>2017-06-09T06:41:23.000Z</published>
    <updated>2023-06-05T05:33:26.597Z</updated>
    
    <content type="html"><![CDATA[<p>WWDC 2017 带来了很多惊喜。Swift 4 也伴随着 Xcode 9 测试版来到了我们的面前，很多强大的新特性非常值得我们期待在正式项目中去使用它。因为 Swift 4 是开源的，如果你关注 <code>swift-evolution</code> 这个项目的话，就应该已经提前了解到它的新特性了。本文参考了 WWDC 2017 以及各种资料，把 Swift 4 的这些新特性一一列举出来做介绍和分析，让他们毫无保留地展现在你眼前。</p><h1 id="一、语法改进"><a href="#一、语法改进" class="headerlink" title="一、语法改进"></a>一、语法改进</h1><h2 id="extension-中可以访问-private-的属性"><a href="#extension-中可以访问-private-的属性" class="headerlink" title="extension 中可以访问 private 的属性"></a>extension 中可以访问 private 的属性</h2><p>考虑以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>: <span class="title class_">Equatable</span>, <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secondsSinceReferenceDate: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">==</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">&lt;</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">&lt;</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Date 结构体，并实现 Equatable 和 Comparable 协议。为了让代码更清晰，可读性更好，一般会把对协议的实现放在单独的 extension 中，这也是一种非常符合 Swift 风格的写法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secondsSinceReferenceDate: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Date</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">==</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Date</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">&lt;</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">&lt;</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 Swift 3 中，编译就报错了，因为 extension 中无法获取到 secondsSinceReferenceDate 属性，因为它是 <code>private</code> 的。于是在 Swift 3 中，必须把 private 改为 fileprivate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">    fileprivate let secondsSinceReferenceDate: Double</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是如果用 fileprivate，属性的作用域就会比我们需要的更大，可能会不小心造成属性的滥用。</p><p>在 Swift 4 中，private 的属性的作用域扩大到了 extension 中，并且被限定在了 struct 和 extension 内部，这样就不需要再改成 fileprivate 了，这是最好的结果。</p><h2 id="类型和协议的组合类型"><a href="#类型和协议的组合类型" class="headerlink" title="类型和协议的组合类型"></a>类型和协议的组合类型</h2><p>考虑以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Shakeable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIButton</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UISlider</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="operator">???</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.state.isEnabled &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    control.shake()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Swift 3 中，这里的 <code>???</code> 应该写什么呢？如果写 <code>UIControl</code>，那么 <code>control.shake()</code> 就会报错；如果写 <code>Shakeable</code>，那么 <code>control.state.isEnabled</code> 就会报错。其实我们也可以这样写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="type">UIControl</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.isEnabled &#123;</span><br><span class="line">        <span class="keyword">if</span> control <span class="keyword">is</span> <span class="type">Shakeable</span> &#123;</span><br><span class="line">            (control <span class="keyword">as!</span> <span class="type">Shakeable</span>).shake()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写虽然可以跑通了，但是很丑陋。</p><p>在 Swift 4 中，可以把类型和协议用 <code>&amp;</code> 组合在一起作为一个类型使用，就可以像下面这样写了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Shakeable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIButton</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UISlider</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="type">UIControl</span> &amp; <span class="type">Shakeable</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.state.isEnabled &#123;</span><br><span class="line">        control.shake()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把它声明为了 <code>UIControl &amp; Shakeable</code> 类型。OK，圆满解决。</p><p>PS:<br>这个代码例子是 WWDC 2017 的 PPT 中的，上面的代码有点问题，control.state.isEnabled 这句代码中，state 是没有 isEnabled 这个属性的，改为 <code>control.isEnabled</code> 就可以了。看来苹果的工程师做 PPT 有时候还是不太严谨。</p><p>另外，iOS SDK 中的 API 也用这个特性做了优化，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C API</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCandidateListTouchBarItem</span>&lt;<span class="title">CandidateType</span>&gt; : <span class="title">NSTouchBarItem</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="built_in">NSView</span> &lt;<span class="built_in">NSTextInputClient</span>&gt; *client;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个 API 的 Objective-C 版本是没有问题的，可以知道 client 属性既是一个 NSView，又符合 NSTextInputClient 协议。然而它对应的 Swift 3 版本为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NSCandidateListTouchBarItem</span>&lt;<span class="title class_">CandidateType</span>: <span class="title class_">AnyObject</span>&gt; : <span class="title class_">NSTouchBarItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client: <span class="type">NSView</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅是一个 NSView 类型 &#x2F;(ㄒoㄒ)&#x2F;~~</p><p>在 Swift 4 中，这类 API 做了优化，改成了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NSCandidateListTouchBarItem</span>&lt;<span class="title class_">CandidateType</span>: <span class="title class_">AnyObject</span>&gt; : <span class="title class_">NSTouchBarItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client: (<span class="type">NSView</span> &amp; <span class="type">NSTextInputClient</span>)<span class="operator">?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样类型的声明就更加严谨了。</p><h2 id="Associated-Type-可以追加-Where-约束语句"><a href="#Associated-Type-可以追加-Where-约束语句" class="headerlink" title="Associated Type 可以追加 Where 约束语句"></a>Associated Type 可以追加 Where 约束语句</h2><p>在 Swift 4 中可以在 associatedtype 后面声明的类型后追加 where 语句</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="operator">&lt;</span>xxx<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>看下面是 Swift 4 标准库中 Sequence 中 SubSequence 的声明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="keyword">Self</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="keyword">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它限定了 Sequence 中 Element 这个类型必须和 Iterator.Element 的类型一致。</p><p>通过 where 语句可以对类型添加更多的约束，使其更严谨，避免在使用这个类型时做多余的类型判断。</p><h2 id="新的-Key-Paths-语法"><a href="#新的-Key-Paths-语法" class="headerlink" title="新的 Key Paths 语法"></a>新的 Key Paths 语法</h2><p>先来看看 Swift 3 中 Key Paths 的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span>Members <span class="keyword">class</span> <span class="title class_">Kid</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> nickname: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> age: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> friends: [<span class="type">Kid</span>] <span class="operator">=</span> []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ben <span class="operator">=</span> <span class="type">Kid</span>(nickname: <span class="string">&quot;Benji&quot;</span>, age: <span class="number">5.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kidsNameKeyPath <span class="operator">=</span> <span class="keyword">#keyPath</span>(<span class="type">Kid</span>.nickname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> ben.valueForKeyPath(kidsNameKeyPath)</span><br><span class="line">ben.setValue(<span class="string">&quot;Ben&quot;</span>, forKeyPath: kidsNameKeyPath)</span><br></pre></td></tr></table></figure><p>Swift 4 中创建一个 KeyPath 用 <code>\</code> 作为开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Kid.nickname</span><br></pre></td></tr></table></figure><p>当编译器可以推导出类型时，可以省略基础类型部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\.nickname</span><br></pre></td></tr></table></figure><p>上面的代码在 Swift 4 中就可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Kid &#123;</span><br><span class="line">    var nickname: String = &quot;&quot;</span><br><span class="line">    var age: Double = 0.0</span><br><span class="line">    var friends: [Kid] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ben = Kid(nickname: &quot;Benji&quot;, age: 8, friends: [])</span><br><span class="line"></span><br><span class="line">let name = ben[keyPath: \Kid.nickname]</span><br><span class="line">ben[keyPath: \Kid.nickname] = &quot;BigBen&quot;</span><br></pre></td></tr></table></figure><p>相比 Swift 3，Swift 4 的 Key Paths 具有以下优势：</p><ol><li>类型可以定义为 class、struct</li><li>定义类型时无需加上 @objcMembers、dynamic 等关键字</li><li>性能更好</li><li>类型安全和类型推断，例如 <code>ben.valueForKeyPath(kidsNameKeyPath)</code> 返回的类型是 Any，<code>ben[keyPath: \Kid.nickname]</code> 直接返回 String 类型</li><li>可以在所有值类型上使用</li></ol><h2 id="下标支持泛型"><a href="#下标支持泛型" class="headerlink" title="下标支持泛型"></a>下标支持泛型</h2><p>有时候会写一些数据容器，Swift 支持通过下标来读写容器中的数据，但是如果容器类中的数据类型定义为泛型，以前的下标语法就只能返回 Any，在取出值后需要用 <code>as?</code> 来转换类型。Swift 4 定义下标也可以使用泛型了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GenericDictionary</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>, <span class="title class_">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">Key</span>: <span class="type">Value</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">data</span>: [<span class="params">Key</span>: <span class="type">Value</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.data <span class="operator">=</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">T</span>&gt;(<span class="params">key</span>: <span class="type">Key</span>) -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> data[key] <span class="keyword">as?</span> <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dictionary <span class="operator">=</span> <span class="type">GenericDictionary</span>(data: [<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Xiaoming&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name: <span class="type">String</span>? <span class="operator">=</span> dictionary[<span class="string">&quot;Name&quot;</span>] <span class="comment">// 不需要再写 as? String</span></span><br></pre></td></tr></table></figure><h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><h2 id="Unicode-字符串在计算-count-时的正确性改善"><a href="#Unicode-字符串在计算-count-时的正确性改善" class="headerlink" title="Unicode 字符串在计算 count 时的正确性改善"></a>Unicode 字符串在计算 count 时的正确性改善</h2><p>在 Unicode 中，有些字符是由几个其它字符组成的，比如 <code>é</code> 这个字符，它可以用 <code>\u&#123;E9&#125;</code> 来表示，也可以用 e 字符和上面一撇字符组合在一起表示 <code>\u&#123;65&#125;\u&#123;301&#125;</code>。</p><p>考虑以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> family <span class="operator">=</span> <span class="string">&quot;👩&quot;</span></span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👩&quot;</span></span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👧&quot;</span> </span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👦&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(family)</span><br><span class="line"><span class="built_in">print</span>(family.characters.count)</span><br></pre></td></tr></table></figure><p>这个 family 是一个由多个字符组合成的字符，打印出来的结果为 👩‍👩‍👧‍👦。上面的代码在 Swift 3 中打印的 count 数是 4，在 Swift 4 中打印出的 count 是 1。</p><h2 id="更快的字符处理速度"><a href="#更快的字符处理速度" class="headerlink" title="更快的字符处理速度"></a>更快的字符处理速度</h2><p>Swift 4 的字符串优化了底层实现，对于英语、法语、德语、西班牙语的处理速度提高了 3.5 倍。</p><p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181745@2x.png"></p><p>对于简体中文、日语的处理速度提高了 2.5 倍。</p><p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181757@2x.png"></p><h2 id="去掉-characters"><a href="#去掉-characters" class="headerlink" title="去掉 characters"></a>去掉 characters</h2><p>Swift 3 中的 String 需要通过 characters 去调用的属性方法，在 Swift 4 中可以通过 String 对象本身直接调用，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">var i = values.characters.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">    if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">        print(&quot;found it!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i = values.characters.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 4 可以把上面代码中的所有的 characters 都去掉，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">var i = values.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">    if values[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">        print(&quot;found it!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i = values.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="One-sided-Slicing"><a href="#One-sided-Slicing" class="headerlink" title="One-sided Slicing"></a>One-sided Slicing</h2><p>Swift 4 新增了一个语法糖可以对字符串进行单侧边界取子串。</p><p>Swift 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;abcdefg&quot;</span><br><span class="line">let startSlicingIndex = values.index(values.startIndex, offsetBy: 3)</span><br><span class="line">let subvalues = values[startSlicingIndex..&lt;values.endIndex]</span><br><span class="line">// defg</span><br></pre></td></tr></table></figure><p>Swift 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;abcdefg&quot;</span><br><span class="line">let startSlicingIndex = values.index(values.startIndex, offsetBy: 3)</span><br><span class="line">let subvalues = values[startSlicingIndex...] // One-sided Slicing</span><br><span class="line">// defg</span><br></pre></td></tr></table></figure><h2 id="String-当做-Collection-来用"><a href="#String-当做-Collection-来用" class="headerlink" title="String 当做 Collection 来用"></a>String 当做 Collection 来用</h2><p>Swift 4 中 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。例如：</p><p>翻转字符串：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(abc.reversed()))</span><br><span class="line"><span class="comment">// cba</span></span><br></pre></td></tr></table></figure><p>遍历字符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> abc &#123;</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Map、Filter、Reduce:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">_</span> <span class="operator">=</span> abc.map &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable">$0</span>.description)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> abc.filter &#123; <span class="variable">$0</span> <span class="operator">==</span> <span class="string">&quot;b&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> abc.reduce(<span class="string">&quot;1&quot;</span>) &#123; (result, c) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="keyword">return</span> result <span class="operator">+</span> <span class="type">String</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h2><p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-182237@2x.png"></p><p>在 Swift 中，String 的背后有个 Owner Object 来跟踪和管理这个 String，String 对象在内存中的存储由内存其实地址、字符数、指向 Owner Object 指针组成。Owner Object 指针指向 Owner Object 对象，Owner Object 对象持有 String Buffer。当对 String 做取子字符串操作时，子字符串的 Owner Object 指针会和原字符串指向同一个对象，因此子字符串的 Owner Object 会持有原 String 的 Buffer。当原字符串销毁时，由于原字符串的 Buffer 被子字符串的 Owner Object 持有了，原字符串 Buffer 并不会释放，造成极大的内存浪费。</p><p>在 Swift 4 中，做取子串操作的结果是一个 Substring 类型，它无法直接赋值给需要 String 类型的地方。必须用 String(<substring>) 包一层，系统会通过复制创建出一个新的字符串对象，这样原字符串在销毁时，原字符串的 Buffer 就可以完全释放了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let big = downloadHugeString()</span><br><span class="line">let small = extractTinyString(from: big)</span><br><span class="line"></span><br><span class="line">mainView.titleLabel.text = small // Swift 4 编译报错</span><br><span class="line"></span><br><span class="line">mainView.titleLabel.text = String(small) // 编译通过</span><br></pre></td></tr></table></figure><h2 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h2><p>Swift 3 中写很长的字符串只能写在一行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">tellJoke</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">character</span>: <span class="type">Character</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> punchline <span class="operator">=</span> name.filter &#123; <span class="variable">$0</span> <span class="operator">!=</span> character &#125;</span><br><span class="line">    <span class="keyword">let</span> n <span class="operator">=</span> name.count <span class="operator">-</span> punchline.count</span><br><span class="line">    <span class="keyword">let</span> joke <span class="operator">=</span> <span class="string">&quot;Q: Why does <span class="subst">\(name)</span> have <span class="subst">\(n)</span> <span class="subst">\(character)</span>&#x27;s in their name?<span class="subst">\n</span>A: I don&#x27;t know, why does <span class="subst">\(name)</span> have <span class="subst">\(n)</span> <span class="subst">\(character)</span>&#x27;s in their name?<span class="subst">\n</span>Q: Because otherwise they&#x27;d be called <span class="subst">\(punchline)</span>.&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(joke)</span><br><span class="line">&#125;</span><br><span class="line">tellJoke(name: <span class="string">&quot;Edward Woodward&quot;</span>, character: <span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure><p>字符串中间有换行只能通过添加 <code>\n</code> 字符来代表换行。 </p><p>Swift 4 可以把字符串写在一对 <code>&quot;&quot;&quot;</code> 中，这样字符串就可以写成多行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func tellJoke(name: String, character: Character) &#123;</span><br><span class="line">    let punchline = name.filter &#123; $0 != character &#125;</span><br><span class="line">    let n = name.count - punchline.count</span><br><span class="line">    let joke = &quot;&quot;&quot;</span><br><span class="line">        Q: Why does \(name) have \(n) \(character)&#x27;s in their name?</span><br><span class="line">        A: I don&#x27;t know, why does \(name) have \(n) \(character)&#x27;s in their name?</span><br><span class="line">        Q: Because otherwise they&#x27;d be called \(punchline).</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    print(joke)</span><br><span class="line">&#125;</span><br><span class="line">tellJoke(name: &quot;Edward Woodward&quot;, character: &quot;d&quot;)</span><br></pre></td></tr></table></figure><h1 id="三、Swift-标准库"><a href="#三、Swift-标准库" class="headerlink" title="三、Swift 标准库"></a>三、Swift 标准库</h1><h2 id="Encoding-and-Decoding"><a href="#Encoding-and-Decoding" class="headerlink" title="Encoding and Decoding"></a>Encoding and Decoding</h2><p>当需要将一个对象持久化时，需要把这个对象序列化，往常的做法是实现 NSCoding 协议，写过的人应该都知道实现 NSCoding 协议的代码写起来很痛苦，尤其是当属性非常多的时候。几年前有一个工具能自动生成 Objective-C 的实现 NSCoding 协议代码，当时用着还不错，但后来这个工具已经没有人维护很久了，而且不支持 Swift。</p><p>Swift 4 中引入了 <code>Codable</code> 帮我们解决了这个问题。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Language</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想将这个 Language 对象的实例持久化，只需要让 Language 符合 Codable 协议即可，Language 中不用写别的代码。符合了 Codable 协议以后，可以选择把对象 encode 成 JSON 或者 PropertyList。</p><p>Encode 操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let swift = Language(name: &quot;Swift&quot;, version: 4)</span><br><span class="line">if let encoded = try? JSONEncoder().encode(swift) &#123;</span><br><span class="line">    // 把 encoded 保存起来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Decode 操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let decoded = try? JSONDecoder().decode(Language.self, from: encoded) &#123;</span><br><span class="line">    print(decoded.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sequence-改进"><a href="#Sequence-改进" class="headerlink" title="Sequence 改进"></a>Sequence 改进</h2><p>Swift 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype Iterator: IteratorProtocol</span><br><span class="line">    func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    associatedtype Iterator: IteratorProtocol where Iterator.Element == Element</span><br><span class="line">    func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Swift 4 中的 associatedtype 支持追加 where 语句，所以 Sequence 做了这样的改进。<br>Swift 4 中获取 Sequence 的元素类型可以不用 Iterator.Element，而是直接取 Element。</p><p>SubSequence 也做了修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype SubSequence: Sequence </span><br><span class="line">        where SubSequence.SubSequence == SubSequence,</span><br><span class="line">              SubSequence.Element == Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 where 语句的限定，保证了类型正确，避免在使用 Sequence 时做一些不必要的类型判断。</p><p>Collection 也有一些类似的修改。</p><h2 id="Protocol-oriented-integers"><a href="#Protocol-oriented-integers" class="headerlink" title="Protocol-oriented integers"></a>Protocol-oriented integers</h2><p>整数类型符合的协议有修改，新增了 <code>FixedWidthInteger</code> 等协议，具体的协议继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                +-------------+   +-------------+</span><br><span class="line">        +------&gt;+   Numeric   |   | Comparable  |</span><br><span class="line">        |       |   (+,-,*)   |   | (==,&lt;,&gt;,...)|</span><br><span class="line">        |       +------------++   +---+---------+</span><br><span class="line">        |                     ^       ^</span><br><span class="line">+-------+------------+        |       |</span><br><span class="line">|    SignedNumeric   |      +-+-------+-----------+</span><br><span class="line">|     (unary -)      |      |    BinaryInteger    |</span><br><span class="line">+------+-------------+      |(words,%,bitwise,...)|</span><br><span class="line">       ^                    ++---+-----+----------+</span><br><span class="line">       |         +-----------^   ^     ^---------------+</span><br><span class="line">       |         |               |                     |</span><br><span class="line">+------+---------++    +---------+---------------+  +--+----------------+</span><br><span class="line">|  SignedInteger  |    |  FixedWidthInteger      |  |  UnsignedInteger  |</span><br><span class="line">|                 |    |(endianness,overflow,...)|  |                   |</span><br><span class="line">+---------------+-+    +-+--------------------+--+  +-+-----------------+</span><br><span class="line">                ^        ^                    ^       ^</span><br><span class="line">                |        |                    |       |</span><br><span class="line">                |        |                    |       |</span><br><span class="line">               ++--------+-+                +-+-------+-+</span><br><span class="line">               |Int family |-+              |UInt family|-+</span><br><span class="line">               +-----------+ |              +-----------+ |</span><br><span class="line">                 +-----------+                +-----------+</span><br></pre></td></tr></table></figure><h2 id="Dictionary-and-Set-enhancements"><a href="#Dictionary-and-Set-enhancements" class="headerlink" title="Dictionary and Set enhancements"></a>Dictionary and Set enhancements</h2><p>这里简单列一下 Dictionary 和 Set 增强了哪些功能：</p><ol><li>通过 Sequence 来初始化</li><li>可以包含重复的 Key</li><li>Filter 的结果的类型和原类型一致</li><li>Dictionary 的 mapValues 方法</li><li>Dictionary 的默认值</li><li>Dictionary 可以分组</li><li>Dictionary 可以翻转</li></ol><h2 id="NSNumber-bridging-and-Numeric-types"><a href="#NSNumber-bridging-and-Numeric-types" class="headerlink" title="NSNumber bridging and Numeric types"></a>NSNumber bridging and Numeric types</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let n = NSNumber(value: 999)</span><br><span class="line">let v = n as? UInt8 // Swift 4: nil, Swift 3: 231</span><br></pre></td></tr></table></figure><p>在 Swift 4 中，把一个值为 999 的 NSNumber 转换为 UInt8 后，能正确的返回 <code>nil</code>，而在 Swift 3 中会不可预料的返回 231。</p><h2 id="MutableCollection-swapAt"><a href="#MutableCollection-swapAt" class="headerlink" title="MutableCollection.swapAt(::)"></a>MutableCollection.swapAt(<em>:</em>:)</h2><p>MutableCollection 现在有了一个新方法 swapAt(<em>:</em>:) 用来交换两个位置的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mutableArray = [1, 2, 3, 4]</span><br><span class="line">mutableArray.swapAt(1, 2)</span><br><span class="line">print(mutableArray)</span><br><span class="line">// 打印结果：[1, 3, 2, 4]</span><br></pre></td></tr></table></figure><h1 id="四、构建过程改进"><a href="#四、构建过程改进" class="headerlink" title="四、构建过程改进"></a>四、构建过程改进</h1><h2 id="New-Build-System"><a href="#New-Build-System" class="headerlink" title="New Build System"></a>New Build System</h2><p>Xcode 9 引入了 New Build System，可在 Xcode 9 的 <code>File -&gt; Project Settings...</code> 中选择开启。</p><p><img src="http://or9vkv08s.bkt.clouddn.com/WechatIMG252.jpeg"></p><h2 id="预编译-Bridging-Headers-文件"><a href="#预编译-Bridging-Headers-文件" class="headerlink" title="预编译 Bridging Headers 文件"></a>预编译 Bridging Headers 文件</h2><p>对于 Swift 和 Objective-C 混合的项目，Swift 调用 Objective-C 时，需要建立一个 Bridging Headers 文件，然后把 Swift 要调用的 Objective-C 类的头文件都写在里面，编译器会读取 Bridging Headers 中的头文件，然后生成一个庞大的 Swift 文件，文件内容是这些头文件内的 API 的 Swift 版本。然后编译器会在编译每一个 Swift 文件时，把这个庞大的 Swift 文件的内容插入进去。</p><p>有了预编译 Bridging Headers 以后，编译器会在预编译阶段把 Bridging Headers 编译一次，然后插入到每个 Swift 文件中，这样就大大提高了编译速度。</p><p>Xcode 9 和 Swift 4 对于 Swift 和 Objective-C 混合编译的速度提高了 40%。</p><h2 id="Indexing-可以在编译的同时进行"><a href="#Indexing-可以在编译的同时进行" class="headerlink" title="Indexing 可以在编译的同时进行"></a>Indexing 可以在编译的同时进行</h2><p>用 Swift 开发项目时，近几个版本的 Xcode 进行 Indexing 的速度慢的令人发指。Xcode 9 和 Swift 4 在这方面做了优化，可以在编译的同时进行 Indexing，一般编译结束后 Indexing 也会同时完成。</p><h2 id="COW-Existential-Containers"><a href="#COW-Existential-Containers" class="headerlink" title="COW Existential Containers"></a>COW Existential Containers</h2><p>Swift 中有个东西叫 Existential Containers，它用来保存未知类型的值，它的内部是一个 Inline value buffer，如果 Inline value buffer 中的值占用空间很大时，这个值会被分配在堆上，然而在堆上分配内存是一个性能比较慢的操作。</p><p>Swift 4 中为了优化性能引入了 COW Existential Containers，这里的 COW 就代表 “Copy-On-Write”，当存在多个相同的值时，他们会共用 buffer 上的空间，直到某个值被修改时，这个被修改的值才会被拷贝一份并分配内存空间。</p><h2 id="移除未调用的协议实现"><a href="#移除未调用的协议实现" class="headerlink" title="移除未调用的协议实现"></a>移除未调用的协议实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">    private let secondsSinceReferenceDate: Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Date: Equatable &#123;</span><br><span class="line">    static func ==(lhs: Date, rhs: Date) -&gt; Bool &#123;</span><br><span class="line">        return lhs.secondsSinceReferenceDate == rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Date: Comparable &#123;</span><br><span class="line">    static func &lt;(lhs: Date, rhs: Date) -&gt; Bool &#123;</span><br><span class="line">        return lhs.secondsSinceReferenceDate &lt; rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面例子，Date 实现了 Equatable 和 Comparable 协议。编译时如果编译器发现没有任何地方调用了对 Date 进行大小比较的方法，编译器会移除 Comparable 协议的实现，来达到减小包大小的目的。</p><h2 id="减少隐式-objc-自动推断"><a href="#减少隐式-objc-自动推断" class="headerlink" title="减少隐式 @objc 自动推断"></a>减少隐式 @objc 自动推断</h2><p>在项目中想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc，例如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>() &#123; <span class="operator">...</span> &#125; <span class="comment">// 包含隐式的 @objc</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">show</span>() &#123; <span class="operator">...</span> &#125; <span class="comment">// 包含隐式的 @objc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样很多并不需要暴露给 Objective-C 也被加上了 @objc。大量 @objc 会导致二进制文件大小的增加。</p><p>在 Swift 4 中，隐式 @objc 自动推断只会发生在很少的当必须要使用 @objc 的情况，比如：</p><ol><li>复写父类的 Objective-C 方法</li><li>符合一个 Objective-C 的协议</li></ol><p>其它大多数地方必须手工显示的加上 @objc。</p><p>减少了隐式 @objc 自动推断后，Apple Music app 的包大小减少了 5.7%。</p><h1 id="五、-Exclusive-Access-to-Memory"><a href="#五、-Exclusive-Access-to-Memory" class="headerlink" title="五、 Exclusive Access to Memory"></a>五、 Exclusive Access to Memory</h1><p>在遍历一个 Collection 的时候可以去修改每一个元素的指，但是在遍历时如果去添加或删除一个元素就可能会引起 Crash。</p><p>例如为 MutableCollection 扩展一个 modifyEach 方法来修改每个元素的值，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">MutableCollection</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">modifyEach</span>(<span class="keyword">_</span> <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">Element</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="keyword">self</span>.indices &#123;</span><br><span class="line">            body(<span class="operator">&amp;</span><span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如在调用 modifyEach 时去删除元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3]</span><br><span class="line">numbers.modifyEach &#123; element in</span><br><span class="line">    element *= 2</span><br><span class="line">    numbers.removeAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会在运行时 Crash。Swift 4 中引入了 Exclusive Access to Memory，是的这个错误可以在编译时被检查出来。</p><h1 id="六、-其它"><a href="#六、-其它" class="headerlink" title="六、 其它"></a>六、 其它</h1><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。</p><ol><li>Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。</li><li>Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。</li><li>Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。</li><li>迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。</li></ol><p>总结：当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，后续可以再迁移到 Swift 4。或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。</p><h2 id="Symbol-Size"><a href="#Symbol-Size" class="headerlink" title="Symbol Size"></a>Symbol Size</h2><p>Swift 4 的 Symbol Size 要比 Swift 3 减少了三分之二。</p><h1 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h1><ul><li>WWDC 2017 Session 402 《What’s New in Swift》</li><li>WWDC 2017 Session 212 《What’s New in Foundation》</li><li>WWDC 2017 Session 102 《Platforms State of the Union》</li><li>《Swift Language Programming (Swift 4.0)》</li><li><a href="https://github.com/apple/swift-evolution">https://github.com/apple/swift-evolution</a></li><li><a href="https://github.com/ole/whats-new-in-swift-4">https://github.com/ole/whats-new-in-swift-4</a></li><li><a href="https://www.raywenderlich.com/163857/whats-new-swift-4">https://www.raywenderlich.com/163857/whats-new-swift-4</a></li><li><a href="https://www.hackingwithswift.com/swift4">https://www.hackingwithswift.com/swift4</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WWDC 2017 带来了很多惊喜。Swift 4 也伴随着 Xcode 9 测试版来到了我们的面前，很多强大的新特性非常值得我们期待在正式项目中去使用它。因为 Swift 4 是开源的，如果你关注 &lt;code&gt;swift-evolution&lt;/code&gt; 这个项目的话，就</summary>
      
    
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/categories/Swift/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift 中的 Sequence（二）</title>
    <link href="https://liuduoios.github.io/sequence_advanced/"/>
    <id>https://liuduoios.github.io/sequence_advanced/</id>
    <published>2017-06-07T06:17:09.000Z</published>
    <updated>2023-06-05T05:33:26.596Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇 <a href="http://liuduo.me/2017/05/26/sequence_base/">Swift 中的 Sequence 基础篇</a></p><p>撰写本文时 Swift 版本是 4.0 beta。</p><h1 id="值类型-Iterator-和引用类型-Iterator"><a href="#值类型-Iterator-和引用类型-Iterator" class="headerlink" title="值类型 Iterator 和引用类型 Iterator"></a>值类型 Iterator 和引用类型 Iterator</h1><h2 id="值类型-Iterator"><a href="#值类型-Iterator" class="headerlink" title="值类型 Iterator"></a>值类型 Iterator</h2><p>一般 Iterator 都是值类型的，值类型的 Iterator 的意思是：当把 Iterator 赋值给一个新变量时，是把原 Iterator 的所有状态拷贝了一份赋值给新的 Iterator，原 Iterator 在继续迭代时不会影响新的 Iterator。</p><p>例如用 <code>stride</code> 函数创建一个简单的 Sequence，它从 0 开始，到 9 截止，每次递增 1，即为 [0, 1, 2, …, 8, 9]。<br>然后获取到它的 Iterator，调用 next() 进行迭代。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq <span class="operator">=</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">10</span>, by: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> i1 <span class="operator">=</span> seq.makeIterator()</span><br><span class="line">i1.next() <span class="comment">// Optional(0)</span></span><br><span class="line">i1.next() <span class="comment">// Optional(1)</span></span><br></pre></td></tr></table></figure><p>然后做一个赋值操作，创建一个新的 i2，并把 i1 的值赋给 i2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i2 <span class="operator">=</span> i1</span><br></pre></td></tr></table></figure><p>再用下面代码做测试</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i1.next() <span class="comment">// Optional(2)</span></span><br><span class="line">i1.next() <span class="comment">// Optional(3)</span></span><br><span class="line">i2.next() <span class="comment">// Optional(2)</span></span><br><span class="line">i2.next() <span class="comment">// Optional(3)</span></span><br></pre></td></tr></table></figure><p>从打印的结果会发现：i1 和 i2 是两个独立的 Iterator，他们互不影响，赋值时对 i1 做了一份完整的拷贝。</p><p>所以这里的 Iterator 是一个值类型 Iterator。</p><h2 id="引用类型-Iterator"><a href="#引用类型-Iterator" class="headerlink" title="引用类型 Iterator"></a>引用类型 Iterator</h2><p>可以把任何一个值类型 Iterator 用 <code>AnyIterator</code> 这个包一下就形成了一个引用类型的 Iterator。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i3 <span class="operator">=</span> <span class="type">AnyIterator</span>(i1)</span><br><span class="line"><span class="keyword">var</span> i4 <span class="operator">=</span> i3</span><br></pre></td></tr></table></figure><p>做以下测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i3.next() <span class="comment">// Optional(4)</span></span><br><span class="line">i4.next() <span class="comment">// Optional(5)</span></span><br><span class="line">i3.next() <span class="comment">// Optional(6)</span></span><br><span class="line">i3.next() <span class="comment">// Optional(7)</span></span><br></pre></td></tr></table></figure><p>引用类型的 Iterator，再赋值给一个新的变量后，新的 Iterator 和原 Iterator 在进行迭代时会互相对对方产生影响。</p><h1 id="基于函数的-Sequence、Iterator"><a href="#基于函数的-Sequence、Iterator" class="headerlink" title="基于函数的 Sequence、Iterator"></a>基于函数的 Sequence、Iterator</h1><p><code>AnyIterator</code> 有一个初始化器，可以传入一个闭包，AnyIterator 会把这个闭包的内容作为调用 <code>next()</code> 时执行的内容。<br>这样创建一个 Iterator 时可以不用创建一个新的 class 或 struct。</p><p>例如我们可以这样创建一个斐波那契数列的 Iterator：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">fibsIterator</span>() -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> state <span class="operator">=</span> (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> upcomingNumber <span class="operator">=</span> state.<span class="number">0</span></span><br><span class="line">        state <span class="operator">=</span> (state.<span class="number">1</span>, state.<span class="number">0</span> <span class="operator">+</span> state.<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> upcomingNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样创建出来的 Iterator 是引用类型的。</p><p>然后可以用 <code>AnySequence</code> 来创建 Sequence，AnySequence 也有一个支持传入闭包的初始化器，于是可以把上面的函数名作为参数传入。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibsSequence <span class="operator">=</span> <span class="type">AnySequence</span>(fibsIterator)</span><br><span class="line"><span class="type">Array</span>(fibsSequence.prefix(<span class="number">10</span>))</span><br><span class="line"><span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><p>另外，还有一种更简单的方法来创建 Sequence，用 Swift 标准库中的 sequence 函数。  </p><p>这个函数有两个变体：<br>第一个是 <code>sequence(first:next:)</code><br>第一个参数是 Sequence 中的第一个值，第二个参数传入一个闭包作为 next() 的内容。</p><p>例如创建一个从大到小的随机数 Sequence。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> randomNumbers <span class="operator">=</span> <span class="built_in">sequence</span>(first: <span class="number">100</span>) &#123; (previous: <span class="type">UInt32</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> newValue <span class="operator">=</span> arc4random_uniform(previous)</span><br><span class="line">    <span class="keyword">guard</span> newValue <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(randomNumbers)</span><br><span class="line"><span class="comment">// [100, 90, 60, 35, 34, 21, 3]</span></span><br></pre></td></tr></table></figure><p>第二个变体是 <code>sequence(state:next:)</code><br>这个要更为强大，它可以在迭代过程中修改状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibsSequence2 <span class="operator">=</span> <span class="built_in">sequence</span>(state: (<span class="number">0</span>, <span class="number">1</span>)) &#123; (state: <span class="keyword">inout</span> (<span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> upcomingNumber <span class="operator">=</span> state.<span class="number">0</span></span><br><span class="line">    state <span class="operator">=</span> (state.<span class="number">1</span>, state.<span class="number">0</span> <span class="operator">+</span> state.<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> upcomingNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Array</span>(fibsSequence2.prefix(<span class="number">10</span>))</span><br><span class="line"><span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><p>sequence(frist:next:) 和 sequence(state:next:) 的返回值类型是一个 <code>UnfoldSequence</code>。<br>在函数式编程中有 <code>fold</code> 和 <code>unfold</code> 的概念。<br>fold 是把一系列的值变为一个值，例如 reduce 就是一个 fold 操作。<br>unfold 是 fold 的反操作，把一个值展开成一系列的值。</p><h1 id="无穷-Sequence-和有穷-Sequence"><a href="#无穷-Sequence-和有穷-Sequence" class="headerlink" title="无穷 Sequence 和有穷 Sequence"></a>无穷 Sequence 和有穷 Sequence</h1><p>上面创建的斐波那契数列 Sequence 是一个无穷 Sequence，意思是如果不设置一个范围，它可以无限的迭代下去。</p><p>因此上面跑测试代码时用了 prefix 方法来取得一个有限的范围。</p><p>有穷 Sequence 则会在迭代完最后一个值后自动停止迭代。</p><h1 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h1><p>Sequence 的 protocol 定义中有另一个 associatedtype 叫 SubSequence</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">SubSequence</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubSequence 指定了对原 Sequence 切片后的返回值类型。</p><p>对原 Sequence 进行切片的操作有：</p><ul><li><strong>prefix</strong> and <strong>suffix</strong></li><li><strong>dropFirst</strong> and <strong>dropLast</strong></li><li><strong>split</strong></li></ul><p>如果没有指定 SubSequence 的类型，编译器会将其推导为 <code>AnySequence&lt;Iterator.Element&gt;</code> 类型</p><h1 id="Sequence-的稳定性"><a href="#Sequence-的稳定性" class="headerlink" title="Sequence 的稳定性"></a>Sequence 的稳定性</h1><p>由于 Sequence 的协议并没有要求 Sequence 一定是稳定的，所以 Sequence 也可以是不稳定的，也就是说，对 Sequence 进行多次迭代，每次迭代的结果可能会不一样。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="operator">...</span> <span class="keyword">some</span> condition &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> sequence &#123;</span><br><span class="line">    <span class="comment">// No defined behavior</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面代码，对一个 sequence 进行两次 <code>for-in</code> 循环，如果第一次循环中做了某些破坏稳定性的操作，比如改变了状态，那么进行第二次 <code>for-in</code> 循环的结果是不可预知的。</p><p>如果一个 Sequence 也符合了 Collection 协议，那它一定是稳定的，例如 Array，Collection 协议会确保它是稳定的。</p><p>Swift 标准库中有一些函数创建出来的 Sequence 也能保证是稳定的，比如 <code>stride(from:to:by:)</code> 和 <code>stride(from:through:by:)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接上篇 &lt;a href=&quot;http://liuduo.me/2017/05/26/sequence_base/&quot;&gt;Swift 中的 Sequence 基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;撰写本文时 Swift 版本是 4.0 beta。&lt;/p&gt;
&lt;h1 id=&quot;值类型-Itera</summary>
      
    
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中的 Sequence（一）</title>
    <link href="https://liuduoios.github.io/sequence_base/"/>
    <id>https://liuduoios.github.io/sequence_base/</id>
    <published>2017-05-26T10:34:08.000Z</published>
    <updated>2023-06-05T05:33:26.596Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 是一门可以让你按照自己喜欢的方式写代码的语言，它有很强的扩展能力，而它众多的 Collection Protocols 则是这种扩展能力的提供者之一。</p><p>本文介绍一下 Sequence 和 Iterator 的基本概念，及如何实现一个 Sequence。</p><p>撰写本文时的 Swift 版本是 Swift 3.1。</p><h1 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h1><p>Sequence 是一系列相同类型的值的集合，并且提供对这些值的迭代能力。</p><p>迭代一个 Sequence 最常见的方式就是 <code>for-in</code> 循环，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for element in someSequence &#123;</span><br><span class="line">    doSomething(with: element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常把 <code>for-in</code> 循环用在 Array、Dictioanry、Set 等数据结构上，因为他们都实现了 Sequence 协议。</p><p><strong>Sequence 协议的定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype Iterator: IteratorProtocol</span><br><span class="line">    func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sequence 协议只有一个必须实现的方法 <code>makeIterator()</code></p><p><code>makeIterator()</code> 需要返回一个 Iterator，它是一个 IteratorProtocol 类型。</p><p>也就是说只要提供一个 Iterator 就能实现一个 Sequence，那么 Iterator 又是什么呢？</p><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>Iterator 在 Swift 3.1 标准库中即为 IteratorProtocol，它用来为 Sequence 提供迭代能力。对于 Sequence，我们可以用 <code>for-in</code> 来迭代其中的元素，其实 <code>for-in</code> 的背后是 IteratorProtocol 在起作用。</p><p><strong>IteratorProtocol 的定义如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public protocol IteratorProtocol &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    public mutating func next() -&gt; Self.Element?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中仅声明了一个 <code>next()</code> 方法，用来返回 Sequence 中的下一个元素，或者当没有下一个元素时返回 <code>nil</code>。<br>associatedtype 声明了元素的类型。</p><p>举个例子，创建一个动物的数组，对齐进行循环遍历：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let animals = [&quot;Antelope&quot;, &quot;Butterfly&quot;, &quot;Camel&quot;, &quot;Dolphin&quot;]</span><br><span class="line">for animal in animals &#123;</span><br><span class="line">    print(animal)</span><br><span class="line">&#125;</span><br><span class="line">// 打印结果：</span><br><span class="line">Antelope</span><br><span class="line">Butterfly</span><br><span class="line">Camel</span><br><span class="line">Dolphin</span><br></pre></td></tr></table></figure><p>实际上编译器会把以上代码转换成下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var animalIterator = animals.makeIterator()</span><br><span class="line">while let animal = animalIterator.next() &#123;</span><br><span class="line">    print(animal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获取到 animals 数组的 Iterator</li><li>在一个 while 循环中，通过 Iterator 不断获取下一个元素，并对元素进行操作</li><li>当 <code>next()</code> 返回 <code>nil</code> 时，退出循环</li></ol><h1 id="Iterator-实现举例"><a href="#Iterator-实现举例" class="headerlink" title="Iterator 实现举例"></a>Iterator 实现举例</h1><h2 id="举例1：最简单的-Iterator"><a href="#举例1：最简单的-Iterator" class="headerlink" title="举例1：最简单的 Iterator"></a>举例1：最简单的 Iterator</h2><p>最简单的 Iterator 实现就是在 <code>next()</code> 中返回 <code>nil</code>，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct SimplestIterator: IteratorProtocol &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    mutating func next() -&gt; Int? &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时这个 Iterator 不会迭代出任何元素，确切的说，这个 Interator 在迭代时仅调用一次 <code>next()</code> 就结束了。</p><h2 id="举例2：常量-Iterator"><a href="#举例2：常量-Iterator" class="headerlink" title="举例2：常量 Iterator"></a>举例2：常量 Iterator</h2><p>让 <code>next()</code> 返回一个值，也是一种简单的实现，例如下面代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct ConstantIterator: IteratorProtocol &#123;</span><br><span class="line">    typealias Element = Int</span><br><span class="line">    mutating func next() -&gt; Int? &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子实现了一个只返回 1 的 Iterator。</p><h2 id="举例3：斐波那契数列-Iterator"><a href="#举例3：斐波那契数列-Iterator" class="headerlink" title="举例3：斐波那契数列 Iterator"></a>举例3：斐波那契数列 Iterator</h2><p>再看一个复杂一点的例子，斐波那契数列的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct FibsIterator: IteratorProtocol &#123;</span><br><span class="line">    var state = (0, 1)</span><br><span class="line">    mutating func next() -&gt; Int? &#123;</span><br><span class="line">        let upcomingNumber = state.0</span><br><span class="line">        state = (state.1, state.0 + state.1)</span><br><span class="line">        return upcomingNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>state 具有一个初始值 (0, 1)，用元组表示</li><li>每次调用 <code>next()</code> 时，返回 state 元组中的第一个元素，然后更新 state 为 （第二个元素的值，第一个元素 + 第二个元素的和）</li></ol><p>在实现 Iterator 时可以省略 Element 的类型声明，Swift 会通过 next() 的返回值类型来自动推导出 Element 的类型。不过对于实现比较复杂的 Iterator，往往还是会加上类型声明这一句，提高代码可读性。</p><h1 id="实现一个-Sequence"><a href="#实现一个-Sequence" class="headerlink" title="实现一个 Sequence"></a>实现一个 Sequence</h1><p>实现一个 Sequence 首先要实现一个 Iterator。</p><p>我们准备实现这样的一个 Iterator：它接收一个字符串数组，并可以迭代这个数组中所有字符串的首字母。<br>当数组中的最后一个字符串迭代完毕后，退出迭代。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct FirstLetterIterator: IteratorProtocol &#123;</span><br><span class="line">    let strings: [String]</span><br><span class="line">    var offset: Int</span><br><span class="line"></span><br><span class="line">    init(strings: [String]) &#123;</span><br><span class="line">        self.strings = strings</span><br><span class="line">        offset = 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutating func next() -&gt; String? &#123;</span><br><span class="line">        guard offset &lt; strings.endIndex else &#123; return nil &#125;</span><br><span class="line">        let string = strings[offset]</span><br><span class="line">        offset += 1</span><br><span class="line">        return string.substring(to: string.index(string.startIndex, offsetBy: 1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个 Iterator 的需要输入一个字符串数组</li><li>在 <code>next()</code> 中，判断边界，并返回数组中索引为 offset 的字符串的首字母，并把 offset 加 1</li></ol><p>这里省去了 Element 类型的声明，编译器可以根据 next() 的返回值类型推断出 Element 的类型。</p><p>有了已经实现好的 Iterator，就可以很简单的用它实现 Sequence，在 <code>makeIterator()</code> 中返回这个 Iterator 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct FirstLetterSequence: Sequence &#123;</span><br><span class="line">    let strings: [String]</span><br><span class="line"></span><br><span class="line">    func makeIterator() -&gt; FirstLetterIterator &#123;</span><br><span class="line">        return FirstLetterIterator(strings: strings)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 Sequence 已经实现好了，可以测试一下效果。<br>我们可以创建一个 FirstLetterSequence，并用 <code>for-in</code> 循环对其迭代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for letter in FirstLetterSequence(strings: [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]) &#123;</span><br><span class="line">    print(letter)</span><br><span class="line">&#125;</span><br><span class="line">/* 打印结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">o</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>结果为打印出了数组中每个字符串的首字母。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.apple.com/reference/swift/iteratorprotocol">https://developer.apple.com/reference/swift/iteratorprotocol</a></li><li><a href="https://developer.apple.com/reference/swift/sequence">https://developer.apple.com/reference/swift/sequence</a></li><li>《Advanced Swift》by <a href="https://www.objc.io/books/advanced-swift/">objc.io</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Swift 是一门可以让你按照自己喜欢的方式写代码的语言，它有很强的扩展能力，而它众多的 Collection Protocols 则是这种扩展能力的提供者之一。&lt;/p&gt;
&lt;p&gt;本文介绍一下 Sequence 和 Iterator 的基本概念，及如何实现一个 Sequenc</summary>
      
    
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/categories/Swift/"/>
    
    
    <category term="Swift" scheme="https://liuduoios.github.io/tags/Swift/"/>
    
  </entry>
  
</feed>
