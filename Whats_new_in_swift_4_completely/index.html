<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Mist',
    version: '6.0.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="WWDC 2017 带来了很多惊喜。Swift 4 也伴随着 Xcode 9 测试版来到了我们的面前，很多强大的新特性非常值得我们期待在正式项目中去使用它。因为 Swift 4 是开源的，如果你关注 swift-evolution 这个项目的话，就应该已经提前了解到它的新特性了。本文参考了 WWDC 2017 以及各种资料，把 Swift 4 的这些新特性一一列举出来做介绍和分析，让他们毫无保留地">
<meta property="og:type" content="article">
<meta property="og:title" content="最全的 Swift 4 新特性解析">
<meta property="og:url" content="https://liuduoios.github.io/Whats_new_in_swift_4_completely/index.html">
<meta property="og:site_name" content="My Knowledge Library">
<meta property="og:description" content="WWDC 2017 带来了很多惊喜。Swift 4 也伴随着 Xcode 9 测试版来到了我们的面前，很多强大的新特性非常值得我们期待在正式项目中去使用它。因为 Swift 4 是开源的，如果你关注 swift-evolution 这个项目的话，就应该已经提前了解到它的新特性了。本文参考了 WWDC 2017 以及各种资料，把 Swift 4 的这些新特性一一列举出来做介绍和分析，让他们毫无保留地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181745@2x.png">
<meta property="og:image" content="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181757@2x.png">
<meta property="og:image" content="http://or9vkv08s.bkt.clouddn.com/QQ20170609-182237@2x.png">
<meta property="og:image" content="http://or9vkv08s.bkt.clouddn.com/WechatIMG252.jpeg">
<meta property="article:published_time" content="2017-06-09T06:41:23.000Z">
<meta property="article:modified_time" content="2023-06-05T05:33:26.597Z">
<meta property="article:author" content="晨曦微光">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181745@2x.png">



  <link rel="alternate" href="/atom.xml" title="My Knowledge Library" type="application/atom+xml" />




  <link rel="canonical" href="https://liuduoios.github.io/Whats_new_in_swift_4_completely/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>最全的 Swift 4 新特性解析 | My Knowledge Library</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Knowledge Library</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuduoios.github.io/Whats_new_in_swift_4_completely/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Knowledge Library">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">最全的 Swift 4 新特性解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-09T14:41:23+08:00">2017-06-09</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/Whats_new_in_swift_4_completely/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/Whats_new_in_swift_4_completely/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/Whats_new_in_swift_4_completely/" class="leancloud_visitors" data-flag-title="最全的 Swift 4 新特性解析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">54k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">54 mins.</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>WWDC 2017 带来了很多惊喜。Swift 4 也伴随着 Xcode 9 测试版来到了我们的面前，很多强大的新特性非常值得我们期待在正式项目中去使用它。因为 Swift 4 是开源的，如果你关注 <code>swift-evolution</code> 这个项目的话，就应该已经提前了解到它的新特性了。本文参考了 WWDC 2017 以及各种资料，把 Swift 4 的这些新特性一一列举出来做介绍和分析，让他们毫无保留地展现在你眼前。</p>
<h1 id="一、语法改进"><a href="#一、语法改进" class="headerlink" title="一、语法改进"></a>一、语法改进</h1><h2 id="extension-中可以访问-private-的属性"><a href="#extension-中可以访问-private-的属性" class="headerlink" title="extension 中可以访问 private 的属性"></a>extension 中可以访问 private 的属性</h2><p>考虑以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span>: <span class="title class_">Equatable</span>, <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secondsSinceReferenceDate: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">==</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">&lt;</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">&lt;</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个 Date 结构体，并实现 Equatable 和 Comparable 协议。为了让代码更清晰，可读性更好，一般会把对协议的实现放在单独的 extension 中，这也是一种非常符合 Swift 风格的写法，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secondsSinceReferenceDate: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Date</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">==</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">==</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Date</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">&lt;</span>(<span class="params">lhs</span>: <span class="type">Date</span>, <span class="params">rhs</span>: <span class="type">Date</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.secondsSinceReferenceDate <span class="operator">&lt;</span> rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 Swift 3 中，编译就报错了，因为 extension 中无法获取到 secondsSinceReferenceDate 属性，因为它是 <code>private</code> 的。于是在 Swift 3 中，必须把 private 改为 fileprivate。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">    fileprivate let secondsSinceReferenceDate: Double</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是如果用 fileprivate，属性的作用域就会比我们需要的更大，可能会不小心造成属性的滥用。</p>
<p>在 Swift 4 中，private 的属性的作用域扩大到了 extension 中，并且被限定在了 struct 和 extension 内部，这样就不需要再改成 fileprivate 了，这是最好的结果。</p>
<h2 id="类型和协议的组合类型"><a href="#类型和协议的组合类型" class="headerlink" title="类型和协议的组合类型"></a>类型和协议的组合类型</h2><p>考虑以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Shakeable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIButton</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UISlider</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="operator">???</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.state.isEnabled &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    control.shake()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Swift 3 中，这里的 <code>???</code> 应该写什么呢？如果写 <code>UIControl</code>，那么 <code>control.shake()</code> 就会报错；如果写 <code>Shakeable</code>，那么 <code>control.state.isEnabled</code> 就会报错。其实我们也可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="type">UIControl</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.isEnabled &#123;</span><br><span class="line">        <span class="keyword">if</span> control <span class="keyword">is</span> <span class="type">Shakeable</span> &#123;</span><br><span class="line">            (control <span class="keyword">as!</span> <span class="type">Shakeable</span>).shake()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写虽然可以跑通了，但是很丑陋。</p>
<p>在 Swift 4 中，可以把类型和协议用 <code>&amp;</code> 组合在一起作为一个类型使用，就可以像下面这样写了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Shakeable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">shake</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UIButton</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">UISlider</span>: <span class="title class_">Shakeable</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">shakeEm</span>(<span class="params">controls</span>: [<span class="type">UIControl</span> &amp; <span class="type">Shakeable</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> control <span class="keyword">in</span> controls <span class="keyword">where</span> control.state.isEnabled &#123;</span><br><span class="line">        control.shake()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把它声明为了 <code>UIControl &amp; Shakeable</code> 类型。OK，圆满解决。</p>
<p>PS:<br>这个代码例子是 WWDC 2017 的 PPT 中的，上面的代码有点问题，control.state.isEnabled 这句代码中，state 是没有 isEnabled 这个属性的，改为 <code>control.isEnabled</code> 就可以了。看来苹果的工程师做 PPT 有时候还是不太严谨。</p>
<p>另外，iOS SDK 中的 API 也用这个特性做了优化，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objective-C API</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCandidateListTouchBarItem</span>&lt;<span class="title">CandidateType</span>&gt; : <span class="title">NSTouchBarItem</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">weak</span>) <span class="built_in">NSView</span> &lt;<span class="built_in">NSTextInputClient</span>&gt; *client;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这个 API 的 Objective-C 版本是没有问题的，可以知道 client 属性既是一个 NSView，又符合 NSTextInputClient 协议。然而它对应的 Swift 3 版本为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NSCandidateListTouchBarItem</span>&lt;<span class="title class_">CandidateType</span>: <span class="title class_">AnyObject</span>&gt; : <span class="title class_">NSTouchBarItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client: <span class="type">NSView</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是一个 NSView 类型 &#x2F;(ㄒoㄒ)&#x2F;~~</p>
<p>在 Swift 4 中，这类 API 做了优化，改成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NSCandidateListTouchBarItem</span>&lt;<span class="title class_">CandidateType</span>: <span class="title class_">AnyObject</span>&gt; : <span class="title class_">NSTouchBarItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client: (<span class="type">NSView</span> &amp; <span class="type">NSTextInputClient</span>)<span class="operator">?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样类型的声明就更加严谨了。</p>
<h2 id="Associated-Type-可以追加-Where-约束语句"><a href="#Associated-Type-可以追加-Where-约束语句" class="headerlink" title="Associated Type 可以追加 Where 约束语句"></a>Associated Type 可以追加 Where 约束语句</h2><p>在 Swift 4 中可以在 associatedtype 后面声明的类型后追加 where 语句</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="operator">&lt;</span>xxx<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>看下面是 Swift 4 标准库中 Sequence 中 SubSequence 的声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Sequence</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span> <span class="keyword">where</span> <span class="keyword">Self</span>.<span class="type">Element</span> <span class="operator">==</span> <span class="keyword">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它限定了 Sequence 中 Element 这个类型必须和 Iterator.Element 的类型一致。</p>
<p>通过 where 语句可以对类型添加更多的约束，使其更严谨，避免在使用这个类型时做多余的类型判断。</p>
<h2 id="新的-Key-Paths-语法"><a href="#新的-Key-Paths-语法" class="headerlink" title="新的 Key Paths 语法"></a>新的 Key Paths 语法</h2><p>先来看看 Swift 3 中 Key Paths 的写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span>Members <span class="keyword">class</span> <span class="title class_">Kid</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> nickname: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> age: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> friends: [<span class="type">Kid</span>] <span class="operator">=</span> []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ben <span class="operator">=</span> <span class="type">Kid</span>(nickname: <span class="string">&quot;Benji&quot;</span>, age: <span class="number">5.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kidsNameKeyPath <span class="operator">=</span> <span class="keyword">#keyPath</span>(<span class="type">Kid</span>.nickname)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> ben.valueForKeyPath(kidsNameKeyPath)</span><br><span class="line">ben.setValue(<span class="string">&quot;Ben&quot;</span>, forKeyPath: kidsNameKeyPath)</span><br></pre></td></tr></table></figure>

<p>Swift 4 中创建一个 KeyPath 用 <code>\</code> 作为开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Kid.nickname</span><br></pre></td></tr></table></figure>

<p>当编译器可以推导出类型时，可以省略基础类型部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\.nickname</span><br></pre></td></tr></table></figure>

<p>上面的代码在 Swift 4 中就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Kid &#123;</span><br><span class="line">    var nickname: String = &quot;&quot;</span><br><span class="line">    var age: Double = 0.0</span><br><span class="line">    var friends: [Kid] = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ben = Kid(nickname: &quot;Benji&quot;, age: 8, friends: [])</span><br><span class="line"></span><br><span class="line">let name = ben[keyPath: \Kid.nickname]</span><br><span class="line">ben[keyPath: \Kid.nickname] = &quot;BigBen&quot;</span><br></pre></td></tr></table></figure>

<p>相比 Swift 3，Swift 4 的 Key Paths 具有以下优势：</p>
<ol>
<li>类型可以定义为 class、struct</li>
<li>定义类型时无需加上 @objcMembers、dynamic 等关键字</li>
<li>性能更好</li>
<li>类型安全和类型推断，例如 <code>ben.valueForKeyPath(kidsNameKeyPath)</code> 返回的类型是 Any，<code>ben[keyPath: \Kid.nickname]</code> 直接返回 String 类型</li>
<li>可以在所有值类型上使用</li>
</ol>
<h2 id="下标支持泛型"><a href="#下标支持泛型" class="headerlink" title="下标支持泛型"></a>下标支持泛型</h2><p>有时候会写一些数据容器，Swift 支持通过下标来读写容器中的数据，但是如果容器类中的数据类型定义为泛型，以前的下标语法就只能返回 Any，在取出值后需要用 <code>as?</code> 来转换类型。Swift 4 定义下标也可以使用泛型了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GenericDictionary</span>&lt;<span class="title class_">Key</span>: <span class="title class_">Hashable</span>, <span class="title class_">Value</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> data: [<span class="type">Key</span>: <span class="type">Value</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">data</span>: [<span class="params">Key</span>: <span class="type">Value</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.data <span class="operator">=</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">subscript</span>&lt;<span class="type">T</span>&gt;(<span class="params">key</span>: <span class="type">Key</span>) -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> data[key] <span class="keyword">as?</span> <span class="type">T</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dictionary <span class="operator">=</span> <span class="type">GenericDictionary</span>(data: [<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Xiaoming&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name: <span class="type">String</span>? <span class="operator">=</span> dictionary[<span class="string">&quot;Name&quot;</span>] <span class="comment">// 不需要再写 as? String</span></span><br></pre></td></tr></table></figure>

<h1 id="二、字符串"><a href="#二、字符串" class="headerlink" title="二、字符串"></a>二、字符串</h1><h2 id="Unicode-字符串在计算-count-时的正确性改善"><a href="#Unicode-字符串在计算-count-时的正确性改善" class="headerlink" title="Unicode 字符串在计算 count 时的正确性改善"></a>Unicode 字符串在计算 count 时的正确性改善</h2><p>在 Unicode 中，有些字符是由几个其它字符组成的，比如 <code>é</code> 这个字符，它可以用 <code>\u&#123;E9&#125;</code> 来表示，也可以用 e 字符和上面一撇字符组合在一起表示 <code>\u&#123;65&#125;\u&#123;301&#125;</code>。</p>
<p>考虑以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> family <span class="operator">=</span> <span class="string">&quot;👩&quot;</span></span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👩&quot;</span></span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👧&quot;</span> </span><br><span class="line">family <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;200D&#125;</span>👦&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(family)</span><br><span class="line"><span class="built_in">print</span>(family.characters.count)</span><br></pre></td></tr></table></figure>

<p>这个 family 是一个由多个字符组合成的字符，打印出来的结果为 👩‍👩‍👧‍👦。上面的代码在 Swift 3 中打印的 count 数是 4，在 Swift 4 中打印出的 count 是 1。</p>
<h2 id="更快的字符处理速度"><a href="#更快的字符处理速度" class="headerlink" title="更快的字符处理速度"></a>更快的字符处理速度</h2><p>Swift 4 的字符串优化了底层实现，对于英语、法语、德语、西班牙语的处理速度提高了 3.5 倍。</p>
<p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181745@2x.png"></p>
<p>对于简体中文、日语的处理速度提高了 2.5 倍。</p>
<p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-181757@2x.png"></p>
<h2 id="去掉-characters"><a href="#去掉-characters" class="headerlink" title="去掉 characters"></a>去掉 characters</h2><p>Swift 3 中的 String 需要通过 characters 去调用的属性方法，在 Swift 4 中可以通过 String 对象本身直接调用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">var i = values.characters.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values.characters[i...&lt;values.characters.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">    if values.characters[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">        print(&quot;found it!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i = values.characters.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 4 可以把上面代码中的所有的 characters 都去掉，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;one,two,three...&quot;</span><br><span class="line">var i = values.startIndex</span><br><span class="line"></span><br><span class="line">while let comma = values[i...&lt;values.endIndex].index(of: &quot;,&quot;) &#123;</span><br><span class="line">    if values[i..&lt;comma] == &quot;two&quot; &#123;</span><br><span class="line">        print(&quot;found it!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    i = values.index(after: comma)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="One-sided-Slicing"><a href="#One-sided-Slicing" class="headerlink" title="One-sided Slicing"></a>One-sided Slicing</h2><p>Swift 4 新增了一个语法糖可以对字符串进行单侧边界取子串。</p>
<p>Swift 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;abcdefg&quot;</span><br><span class="line">let startSlicingIndex = values.index(values.startIndex, offsetBy: 3)</span><br><span class="line">let subvalues = values[startSlicingIndex..&lt;values.endIndex]</span><br><span class="line">// defg</span><br></pre></td></tr></table></figure>

<p>Swift 4:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let values = &quot;abcdefg&quot;</span><br><span class="line">let startSlicingIndex = values.index(values.startIndex, offsetBy: 3)</span><br><span class="line">let subvalues = values[startSlicingIndex...] // One-sided Slicing</span><br><span class="line">// defg</span><br></pre></td></tr></table></figure>

<h2 id="String-当做-Collection-来用"><a href="#String-当做-Collection-来用" class="headerlink" title="String 当做 Collection 来用"></a>String 当做 Collection 来用</h2><p>Swift 4 中 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。例如：</p>
<p>翻转字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">String</span>(abc.reversed()))</span><br><span class="line"><span class="comment">// cba</span></span><br></pre></td></tr></table></figure>

<p>遍历字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> abc &#123;</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Map、Filter、Reduce:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">let</span> abc: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">_</span> <span class="operator">=</span> abc.map &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable">$0</span>.description)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">let</span> filtered <span class="operator">=</span> abc.filter &#123; <span class="variable">$0</span> <span class="operator">==</span> <span class="string">&quot;b&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> abc.reduce(<span class="string">&quot;1&quot;</span>) &#123; (result, c) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line">    <span class="keyword">return</span> result <span class="operator">+</span> <span class="type">String</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<h2 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h2><p><img src="http://or9vkv08s.bkt.clouddn.com/QQ20170609-182237@2x.png"></p>
<p>在 Swift 中，String 的背后有个 Owner Object 来跟踪和管理这个 String，String 对象在内存中的存储由内存其实地址、字符数、指向 Owner Object 指针组成。Owner Object 指针指向 Owner Object 对象，Owner Object 对象持有 String Buffer。当对 String 做取子字符串操作时，子字符串的 Owner Object 指针会和原字符串指向同一个对象，因此子字符串的 Owner Object 会持有原 String 的 Buffer。当原字符串销毁时，由于原字符串的 Buffer 被子字符串的 Owner Object 持有了，原字符串 Buffer 并不会释放，造成极大的内存浪费。</p>
<p>在 Swift 4 中，做取子串操作的结果是一个 Substring 类型，它无法直接赋值给需要 String 类型的地方。必须用 String(<substring>) 包一层，系统会通过复制创建出一个新的字符串对象，这样原字符串在销毁时，原字符串的 Buffer 就可以完全释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let big = downloadHugeString()</span><br><span class="line">let small = extractTinyString(from: big)</span><br><span class="line"></span><br><span class="line">mainView.titleLabel.text = small // Swift 4 编译报错</span><br><span class="line"></span><br><span class="line">mainView.titleLabel.text = String(small) // 编译通过</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h2><p>Swift 3 中写很长的字符串只能写在一行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">tellJoke</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">character</span>: <span class="type">Character</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> punchline <span class="operator">=</span> name.filter &#123; <span class="variable">$0</span> <span class="operator">!=</span> character &#125;</span><br><span class="line">    <span class="keyword">let</span> n <span class="operator">=</span> name.count <span class="operator">-</span> punchline.count</span><br><span class="line">    <span class="keyword">let</span> joke <span class="operator">=</span> <span class="string">&quot;Q: Why does <span class="subst">\(name)</span> have <span class="subst">\(n)</span> <span class="subst">\(character)</span>&#x27;s in their name?<span class="subst">\n</span>A: I don&#x27;t know, why does <span class="subst">\(name)</span> have <span class="subst">\(n)</span> <span class="subst">\(character)</span>&#x27;s in their name?<span class="subst">\n</span>Q: Because otherwise they&#x27;d be called <span class="subst">\(punchline)</span>.&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(joke)</span><br><span class="line">&#125;</span><br><span class="line">tellJoke(name: <span class="string">&quot;Edward Woodward&quot;</span>, character: <span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>字符串中间有换行只能通过添加 <code>\n</code> 字符来代表换行。 </p>
<p>Swift 4 可以把字符串写在一对 <code>&quot;&quot;&quot;</code> 中，这样字符串就可以写成多行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func tellJoke(name: String, character: Character) &#123;</span><br><span class="line">    let punchline = name.filter &#123; $0 != character &#125;</span><br><span class="line">    let n = name.count - punchline.count</span><br><span class="line">    let joke = &quot;&quot;&quot;</span><br><span class="line">        Q: Why does \(name) have \(n) \(character)&#x27;s in their name?</span><br><span class="line">        A: I don&#x27;t know, why does \(name) have \(n) \(character)&#x27;s in their name?</span><br><span class="line">        Q: Because otherwise they&#x27;d be called \(punchline).</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">    print(joke)</span><br><span class="line">&#125;</span><br><span class="line">tellJoke(name: &quot;Edward Woodward&quot;, character: &quot;d&quot;)</span><br></pre></td></tr></table></figure>

<h1 id="三、Swift-标准库"><a href="#三、Swift-标准库" class="headerlink" title="三、Swift 标准库"></a>三、Swift 标准库</h1><h2 id="Encoding-and-Decoding"><a href="#Encoding-and-Decoding" class="headerlink" title="Encoding and Decoding"></a>Encoding and Decoding</h2><p>当需要将一个对象持久化时，需要把这个对象序列化，往常的做法是实现 NSCoding 协议，写过的人应该都知道实现 NSCoding 协议的代码写起来很痛苦，尤其是当属性非常多的时候。几年前有一个工具能自动生成 Objective-C 的实现 NSCoding 协议代码，当时用着还不错，但后来这个工具已经没有人维护很久了，而且不支持 Swift。</p>
<p>Swift 4 中引入了 <code>Codable</code> 帮我们解决了这个问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Language</span>: <span class="title class_">Codable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想将这个 Language 对象的实例持久化，只需要让 Language 符合 Codable 协议即可，Language 中不用写别的代码。符合了 Codable 协议以后，可以选择把对象 encode 成 JSON 或者 PropertyList。</p>
<p>Encode 操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let swift = Language(name: &quot;Swift&quot;, version: 4)</span><br><span class="line">if let encoded = try? JSONEncoder().encode(swift) &#123;</span><br><span class="line">    // 把 encoded 保存起来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decode 操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if let decoded = try? JSONDecoder().decode(Language.self, from: encoded) &#123;</span><br><span class="line">    print(decoded.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sequence-改进"><a href="#Sequence-改进" class="headerlink" title="Sequence 改进"></a>Sequence 改进</h2><p>Swift 3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype Iterator: IteratorProtocol</span><br><span class="line">    func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift 4:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    associatedtype Iterator: IteratorProtocol where Iterator.Element == Element</span><br><span class="line">    func makeIterator() -&gt; Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Swift 4 中的 associatedtype 支持追加 where 语句，所以 Sequence 做了这样的改进。<br>Swift 4 中获取 Sequence 的元素类型可以不用 Iterator.Element，而是直接取 Element。</p>
<p>SubSequence 也做了修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol Sequence &#123;</span><br><span class="line">    associatedtype SubSequence: Sequence </span><br><span class="line">        where SubSequence.SubSequence == SubSequence,</span><br><span class="line">              SubSequence.Element == Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 where 语句的限定，保证了类型正确，避免在使用 Sequence 时做一些不必要的类型判断。</p>
<p>Collection 也有一些类似的修改。</p>
<h2 id="Protocol-oriented-integers"><a href="#Protocol-oriented-integers" class="headerlink" title="Protocol-oriented integers"></a>Protocol-oriented integers</h2><p>整数类型符合的协议有修改，新增了 <code>FixedWidthInteger</code> 等协议，具体的协议继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">                +-------------+   +-------------+</span><br><span class="line">        +------&gt;+   Numeric   |   | Comparable  |</span><br><span class="line">        |       |   (+,-,*)   |   | (==,&lt;,&gt;,...)|</span><br><span class="line">        |       +------------++   +---+---------+</span><br><span class="line">        |                     ^       ^</span><br><span class="line">+-------+------------+        |       |</span><br><span class="line">|    SignedNumeric   |      +-+-------+-----------+</span><br><span class="line">|     (unary -)      |      |    BinaryInteger    |</span><br><span class="line">+------+-------------+      |(words,%,bitwise,...)|</span><br><span class="line">       ^                    ++---+-----+----------+</span><br><span class="line">       |         +-----------^   ^     ^---------------+</span><br><span class="line">       |         |               |                     |</span><br><span class="line">+------+---------++    +---------+---------------+  +--+----------------+</span><br><span class="line">|  SignedInteger  |    |  FixedWidthInteger      |  |  UnsignedInteger  |</span><br><span class="line">|                 |    |(endianness,overflow,...)|  |                   |</span><br><span class="line">+---------------+-+    +-+--------------------+--+  +-+-----------------+</span><br><span class="line">                ^        ^                    ^       ^</span><br><span class="line">                |        |                    |       |</span><br><span class="line">                |        |                    |       |</span><br><span class="line">               ++--------+-+                +-+-------+-+</span><br><span class="line">               |Int family |-+              |UInt family|-+</span><br><span class="line">               +-----------+ |              +-----------+ |</span><br><span class="line">                 +-----------+                +-----------+</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary-and-Set-enhancements"><a href="#Dictionary-and-Set-enhancements" class="headerlink" title="Dictionary and Set enhancements"></a>Dictionary and Set enhancements</h2><p>这里简单列一下 Dictionary 和 Set 增强了哪些功能：</p>
<ol>
<li>通过 Sequence 来初始化</li>
<li>可以包含重复的 Key</li>
<li>Filter 的结果的类型和原类型一致</li>
<li>Dictionary 的 mapValues 方法</li>
<li>Dictionary 的默认值</li>
<li>Dictionary 可以分组</li>
<li>Dictionary 可以翻转</li>
</ol>
<h2 id="NSNumber-bridging-and-Numeric-types"><a href="#NSNumber-bridging-and-Numeric-types" class="headerlink" title="NSNumber bridging and Numeric types"></a>NSNumber bridging and Numeric types</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let n = NSNumber(value: 999)</span><br><span class="line">let v = n as? UInt8 // Swift 4: nil, Swift 3: 231</span><br></pre></td></tr></table></figure>

<p>在 Swift 4 中，把一个值为 999 的 NSNumber 转换为 UInt8 后，能正确的返回 <code>nil</code>，而在 Swift 3 中会不可预料的返回 231。</p>
<h2 id="MutableCollection-swapAt"><a href="#MutableCollection-swapAt" class="headerlink" title="MutableCollection.swapAt(::)"></a>MutableCollection.swapAt(<em>:</em>:)</h2><p>MutableCollection 现在有了一个新方法 swapAt(<em>:</em>:) 用来交换两个位置的值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mutableArray = [1, 2, 3, 4]</span><br><span class="line">mutableArray.swapAt(1, 2)</span><br><span class="line">print(mutableArray)</span><br><span class="line">// 打印结果：[1, 3, 2, 4]</span><br></pre></td></tr></table></figure>

<h1 id="四、构建过程改进"><a href="#四、构建过程改进" class="headerlink" title="四、构建过程改进"></a>四、构建过程改进</h1><h2 id="New-Build-System"><a href="#New-Build-System" class="headerlink" title="New Build System"></a>New Build System</h2><p>Xcode 9 引入了 New Build System，可在 Xcode 9 的 <code>File -&gt; Project Settings...</code> 中选择开启。</p>
<p><img src="http://or9vkv08s.bkt.clouddn.com/WechatIMG252.jpeg"></p>
<h2 id="预编译-Bridging-Headers-文件"><a href="#预编译-Bridging-Headers-文件" class="headerlink" title="预编译 Bridging Headers 文件"></a>预编译 Bridging Headers 文件</h2><p>对于 Swift 和 Objective-C 混合的项目，Swift 调用 Objective-C 时，需要建立一个 Bridging Headers 文件，然后把 Swift 要调用的 Objective-C 类的头文件都写在里面，编译器会读取 Bridging Headers 中的头文件，然后生成一个庞大的 Swift 文件，文件内容是这些头文件内的 API 的 Swift 版本。然后编译器会在编译每一个 Swift 文件时，把这个庞大的 Swift 文件的内容插入进去。</p>
<p>有了预编译 Bridging Headers 以后，编译器会在预编译阶段把 Bridging Headers 编译一次，然后插入到每个 Swift 文件中，这样就大大提高了编译速度。</p>
<p>Xcode 9 和 Swift 4 对于 Swift 和 Objective-C 混合编译的速度提高了 40%。</p>
<h2 id="Indexing-可以在编译的同时进行"><a href="#Indexing-可以在编译的同时进行" class="headerlink" title="Indexing 可以在编译的同时进行"></a>Indexing 可以在编译的同时进行</h2><p>用 Swift 开发项目时，近几个版本的 Xcode 进行 Indexing 的速度慢的令人发指。Xcode 9 和 Swift 4 在这方面做了优化，可以在编译的同时进行 Indexing，一般编译结束后 Indexing 也会同时完成。</p>
<h2 id="COW-Existential-Containers"><a href="#COW-Existential-Containers" class="headerlink" title="COW Existential Containers"></a>COW Existential Containers</h2><p>Swift 中有个东西叫 Existential Containers，它用来保存未知类型的值，它的内部是一个 Inline value buffer，如果 Inline value buffer 中的值占用空间很大时，这个值会被分配在堆上，然而在堆上分配内存是一个性能比较慢的操作。</p>
<p>Swift 4 中为了优化性能引入了 COW Existential Containers，这里的 COW 就代表 “Copy-On-Write”，当存在多个相同的值时，他们会共用 buffer 上的空间，直到某个值被修改时，这个被修改的值才会被拷贝一份并分配内存空间。</p>
<h2 id="移除未调用的协议实现"><a href="#移除未调用的协议实现" class="headerlink" title="移除未调用的协议实现"></a>移除未调用的协议实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Date &#123;</span><br><span class="line">    private let secondsSinceReferenceDate: Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Date: Equatable &#123;</span><br><span class="line">    static func ==(lhs: Date, rhs: Date) -&gt; Bool &#123;</span><br><span class="line">        return lhs.secondsSinceReferenceDate == rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Date: Comparable &#123;</span><br><span class="line">    static func &lt;(lhs: Date, rhs: Date) -&gt; Bool &#123;</span><br><span class="line">        return lhs.secondsSinceReferenceDate &lt; rhs.secondsSinceReferenceDate</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面例子，Date 实现了 Equatable 和 Comparable 协议。编译时如果编译器发现没有任何地方调用了对 Date 进行大小比较的方法，编译器会移除 Comparable 协议的实现，来达到减小包大小的目的。</p>
<h2 id="减少隐式-objc-自动推断"><a href="#减少隐式-objc-自动推断" class="headerlink" title="减少隐式 @objc 自动推断"></a>减少隐式 @objc 自动推断</h2><p>在项目中想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc，例如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">print</span>() &#123; <span class="operator">...</span> &#125; <span class="comment">// 包含隐式的 @objc</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">show</span>() &#123; <span class="operator">...</span> &#125; <span class="comment">// 包含隐式的 @objc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样很多并不需要暴露给 Objective-C 也被加上了 @objc。大量 @objc 会导致二进制文件大小的增加。</p>
<p>在 Swift 4 中，隐式 @objc 自动推断只会发生在很少的当必须要使用 @objc 的情况，比如：</p>
<ol>
<li>复写父类的 Objective-C 方法</li>
<li>符合一个 Objective-C 的协议</li>
</ol>
<p>其它大多数地方必须手工显示的加上 @objc。</p>
<p>减少了隐式 @objc 自动推断后，Apple Music app 的包大小减少了 5.7%。</p>
<h1 id="五、-Exclusive-Access-to-Memory"><a href="#五、-Exclusive-Access-to-Memory" class="headerlink" title="五、 Exclusive Access to Memory"></a>五、 Exclusive Access to Memory</h1><p>在遍历一个 Collection 的时候可以去修改每一个元素的指，但是在遍历时如果去添加或删除一个元素就可能会引起 Crash。</p>
<p>例如为 MutableCollection 扩展一个 modifyEach 方法来修改每个元素的值，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">MutableCollection</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">modifyEach</span>(<span class="keyword">_</span> <span class="params">body</span>: (<span class="keyword">inout</span> <span class="type">Element</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="keyword">self</span>.indices &#123;</span><br><span class="line">            body(<span class="operator">&amp;</span><span class="keyword">self</span>[index])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如在调用 modifyEach 时去删除元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3]</span><br><span class="line">numbers.modifyEach &#123; element in</span><br><span class="line">    element *= 2</span><br><span class="line">    numbers.removeAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会在运行时 Crash。Swift 4 中引入了 Exclusive Access to Memory，是的这个错误可以在编译时被检查出来。</p>
<h1 id="六、-其它"><a href="#六、-其它" class="headerlink" title="六、 其它"></a>六、 其它</h1><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Xcode 9 中同时集成了 Swift 3.2 和 Swift 4。</p>
<ol>
<li>Swift 3.2 完全兼容 Swift 3.1，并会在过时的语法或函数上报告警告。</li>
<li>Swift 3.2 具有 Swift 4 的一些写法，但是性能不如 Swift 4。</li>
<li>Swift 3.2 和 Swift 4 可以混合编译，可以指定一部分模块用 Swift 3.2 编译，一部分用 Swift 4 编译。</li>
<li>迁移到 Swift 4 后能获得 Swift 4 所有的新特性，并且性能比 Swift 3.2 好。</li>
</ol>
<p>总结：当 Xcode 正式版发布后，现有的 Swift 代码可以直接升级到 Swift 3.2 而不用做任何改动，后续可以再迁移到 Swift 4。或者直接迁移到 Swift 4 也可以，Swift 4 相比 Swift 3 的 API 变化还是不大的，很多第三方库都可以直接用 Swift 4 编译。</p>
<h2 id="Symbol-Size"><a href="#Symbol-Size" class="headerlink" title="Symbol Size"></a>Symbol Size</h2><p>Swift 4 的 Symbol Size 要比 Swift 3 减少了三分之二。</p>
<h1 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h1><ul>
<li>WWDC 2017 Session 402 《What’s New in Swift》</li>
<li>WWDC 2017 Session 212 《What’s New in Foundation》</li>
<li>WWDC 2017 Session 102 《Platforms State of the Union》</li>
<li>《Swift Language Programming (Swift 4.0)》</li>
<li><a target="_blank" rel="noopener" href="https://github.com/apple/swift-evolution">https://github.com/apple/swift-evolution</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ole/whats-new-in-swift-4">https://github.com/ole/whats-new-in-swift-4</a></li>
<li><a target="_blank" rel="noopener" href="https://www.raywenderlich.com/163857/whats-new-swift-4">https://www.raywenderlich.com/163857/whats-new-swift-4</a></li>
<li><a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/swift4">https://www.hackingwithswift.com/swift4</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/sequence_advanced/" rel="next" title="Swift 中的 Sequence（二）">
                <i class="fa fa-chevron-left"></i> Swift 中的 Sequence（二）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/weird_objectivec/" rel="prev" title="Objective-C 奇葩写法合集">
                Objective-C 奇葩写法合集 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%7C%7C%20archive">
                
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9B"><span class="nav-number">1.</span> <span class="nav-text">一、语法改进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#extension-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE-private-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">extension 中可以访问 private 的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">类型和协议的组合类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Associated-Type-%E5%8F%AF%E4%BB%A5%E8%BF%BD%E5%8A%A0-Where-%E7%BA%A6%E6%9D%9F%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.3.</span> <span class="nav-text">Associated Type 可以追加 Where 约束语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%9A%84-Key-Paths-%E8%AF%AD%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">新的 Key Paths 语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">下标支持泛型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.</span> <span class="nav-text">二、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E8%AE%A1%E7%AE%97-count-%E6%97%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E6%94%B9%E5%96%84"><span class="nav-number">2.1.</span> <span class="nav-text">Unicode 字符串在计算 count 时的正确性改善</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%BF%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E9%80%9F%E5%BA%A6"><span class="nav-number">2.2.</span> <span class="nav-text">更快的字符处理速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%BB%E6%8E%89-characters"><span class="nav-number">2.3.</span> <span class="nav-text">去掉 characters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#One-sided-Slicing"><span class="nav-number">2.4.</span> <span class="nav-text">One-sided Slicing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-%E5%BD%93%E5%81%9A-Collection-%E6%9D%A5%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">String 当做 Collection 来用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Substring"><span class="nav-number">2.6.</span> <span class="nav-text">Substring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.7.</span> <span class="nav-text">多行字符串字面量</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Swift-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-number">3.</span> <span class="nav-text">三、Swift 标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Encoding-and-Decoding"><span class="nav-number">3.1.</span> <span class="nav-text">Encoding and Decoding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequence-%E6%94%B9%E8%BF%9B"><span class="nav-number">3.2.</span> <span class="nav-text">Sequence 改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocol-oriented-integers"><span class="nav-number">3.3.</span> <span class="nav-text">Protocol-oriented integers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dictionary-and-Set-enhancements"><span class="nav-number">3.4.</span> <span class="nav-text">Dictionary and Set enhancements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSNumber-bridging-and-Numeric-types"><span class="nav-number">3.5.</span> <span class="nav-text">NSNumber bridging and Numeric types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MutableCollection-swapAt"><span class="nav-number">3.6.</span> <span class="nav-text">MutableCollection.swapAt(::)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B"><span class="nav-number">4.</span> <span class="nav-text">四、构建过程改进</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#New-Build-System"><span class="nav-number">4.1.</span> <span class="nav-text">New Build System</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91-Bridging-Headers-%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">预编译 Bridging Headers 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Indexing-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E7%BC%96%E8%AF%91%E7%9A%84%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C"><span class="nav-number">4.3.</span> <span class="nav-text">Indexing 可以在编译的同时进行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COW-Existential-Containers"><span class="nav-number">4.4.</span> <span class="nav-text">COW Existential Containers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E6%9C%AA%E8%B0%83%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.5.</span> <span class="nav-text">移除未调用的协议实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E9%9A%90%E5%BC%8F-objc-%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD"><span class="nav-number">4.6.</span> <span class="nav-text">减少隐式 @objc 自动推断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81-Exclusive-Access-to-Memory"><span class="nav-number">5.</span> <span class="nav-text">五、 Exclusive Access to Memory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81-%E5%85%B6%E5%AE%83"><span class="nav-number">6.</span> <span class="nav-text">六、 其它</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol-Size"><span class="nav-number">6.2.</span> <span class="nav-text">Symbol Size</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">七、参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">晨曦微光</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">146k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点总阅读时长">2:26</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.2</div>





        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.2"></script>



  



	





  





  








  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'krbUxLGKWA6SjK4bKeeJcu8Q-gzGzoHsz',
        appKey: 'G2GNz7MLppJZuew6PZbdiZhf',
        placeholder: '填写评论内容',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("nGSnOI7jqHLeho9asFx6j3b9-gzGzoHsz", "r6e5CNQIXNTbVb7KFX4R5rxk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  
  

  

  

  

  

</body>
</html>
